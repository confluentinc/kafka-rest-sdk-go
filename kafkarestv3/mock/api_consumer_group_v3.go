// Code generated by mocker. DO NOT EDIT.
// github.com/travisjeffery/mocker
// Source: ../kafka-rest-sdk-go/kafkarestv3/api_consumer_group_v3.go

package mock

import (
	context "context"
	net_http "net/http"
	sync "sync"

	github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3 "github.com/confluentinc/kafka-rest-sdk-go/kafkarestv3"
)

// ConsumerGroupV3Api is a mock of ConsumerGroupV3Api interface
type ConsumerGroupV3Api struct {
	lockGetKafkaConsumer sync.Mutex
	GetKafkaConsumerFunc func(ctx context.Context, clusterId, consumerGroupId, consumerId string) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ConsumerData, *net_http.Response, error)

	lockGetKafkaConsumerAssignment sync.Mutex
	GetKafkaConsumerAssignmentFunc func(ctx context.Context, clusterId, consumerGroupId, consumerId, topicName string, partitionId int32) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ConsumerAssignmentData, *net_http.Response, error)

	lockGetKafkaConsumerGroup sync.Mutex
	GetKafkaConsumerGroupFunc func(ctx context.Context, clusterId, consumerGroupId string) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ConsumerGroupData, *net_http.Response, error)

	lockGetKafkaConsumerGroupLagSummary sync.Mutex
	GetKafkaConsumerGroupLagSummaryFunc func(ctx context.Context, clusterId, consumerGroupId string) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ConsumerGroupLagSummaryData, *net_http.Response, error)

	lockListKafkaConsumerAssignment sync.Mutex
	ListKafkaConsumerAssignmentFunc func(ctx context.Context, clusterId, consumerGroupId, consumerId string) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ConsumerAssignmentDataList, *net_http.Response, error)

	lockListKafkaConsumerGroups sync.Mutex
	ListKafkaConsumerGroupsFunc func(ctx context.Context, clusterId string) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ConsumerGroupDataList, *net_http.Response, error)

	lockListKafkaConsumerLags sync.Mutex
	ListKafkaConsumerLagsFunc func(ctx context.Context, clusterId, consumerGroupId string) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ConsumerLagDataList, *net_http.Response, error)

	lockListKafkaConsumers sync.Mutex
	ListKafkaConsumersFunc func(ctx context.Context, clusterId, consumerGroupId string) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ConsumerDataList, *net_http.Response, error)

	calls struct {
		GetKafkaConsumer []struct {
			Ctx             context.Context
			ClusterId       string
			ConsumerGroupId string
			ConsumerId      string
		}
		GetKafkaConsumerAssignment []struct {
			Ctx             context.Context
			ClusterId       string
			ConsumerGroupId string
			ConsumerId      string
			TopicName       string
			PartitionId     int32
		}
		GetKafkaConsumerGroup []struct {
			Ctx             context.Context
			ClusterId       string
			ConsumerGroupId string
		}
		GetKafkaConsumerGroupLagSummary []struct {
			Ctx             context.Context
			ClusterId       string
			ConsumerGroupId string
		}
		ListKafkaConsumerAssignment []struct {
			Ctx             context.Context
			ClusterId       string
			ConsumerGroupId string
			ConsumerId      string
		}
		ListKafkaConsumerGroups []struct {
			Ctx       context.Context
			ClusterId string
		}
		ListKafkaConsumerLags []struct {
			Ctx             context.Context
			ClusterId       string
			ConsumerGroupId string
		}
		ListKafkaConsumers []struct {
			Ctx             context.Context
			ClusterId       string
			ConsumerGroupId string
		}
	}
}

// GetKafkaConsumer mocks base method by wrapping the associated func.
func (m *ConsumerGroupV3Api) GetKafkaConsumer(ctx context.Context, clusterId, consumerGroupId, consumerId string) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ConsumerData, *net_http.Response, error) {
	m.lockGetKafkaConsumer.Lock()
	defer m.lockGetKafkaConsumer.Unlock()

	if m.GetKafkaConsumerFunc == nil {
		panic("mocker: ConsumerGroupV3Api.GetKafkaConsumerFunc is nil but ConsumerGroupV3Api.GetKafkaConsumer was called.")
	}

	call := struct {
		Ctx             context.Context
		ClusterId       string
		ConsumerGroupId string
		ConsumerId      string
	}{
		Ctx:             ctx,
		ClusterId:       clusterId,
		ConsumerGroupId: consumerGroupId,
		ConsumerId:      consumerId,
	}

	m.calls.GetKafkaConsumer = append(m.calls.GetKafkaConsumer, call)

	return m.GetKafkaConsumerFunc(ctx, clusterId, consumerGroupId, consumerId)
}

// GetKafkaConsumerCalled returns true if GetKafkaConsumer was called at least once.
func (m *ConsumerGroupV3Api) GetKafkaConsumerCalled() bool {
	m.lockGetKafkaConsumer.Lock()
	defer m.lockGetKafkaConsumer.Unlock()

	return len(m.calls.GetKafkaConsumer) > 0
}

// GetKafkaConsumerCalls returns the calls made to GetKafkaConsumer.
func (m *ConsumerGroupV3Api) GetKafkaConsumerCalls() []struct {
	Ctx             context.Context
	ClusterId       string
	ConsumerGroupId string
	ConsumerId      string
} {
	m.lockGetKafkaConsumer.Lock()
	defer m.lockGetKafkaConsumer.Unlock()

	return m.calls.GetKafkaConsumer
}

// GetKafkaConsumerAssignment mocks base method by wrapping the associated func.
func (m *ConsumerGroupV3Api) GetKafkaConsumerAssignment(ctx context.Context, clusterId, consumerGroupId, consumerId, topicName string, partitionId int32) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ConsumerAssignmentData, *net_http.Response, error) {
	m.lockGetKafkaConsumerAssignment.Lock()
	defer m.lockGetKafkaConsumerAssignment.Unlock()

	if m.GetKafkaConsumerAssignmentFunc == nil {
		panic("mocker: ConsumerGroupV3Api.GetKafkaConsumerAssignmentFunc is nil but ConsumerGroupV3Api.GetKafkaConsumerAssignment was called.")
	}

	call := struct {
		Ctx             context.Context
		ClusterId       string
		ConsumerGroupId string
		ConsumerId      string
		TopicName       string
		PartitionId     int32
	}{
		Ctx:             ctx,
		ClusterId:       clusterId,
		ConsumerGroupId: consumerGroupId,
		ConsumerId:      consumerId,
		TopicName:       topicName,
		PartitionId:     partitionId,
	}

	m.calls.GetKafkaConsumerAssignment = append(m.calls.GetKafkaConsumerAssignment, call)

	return m.GetKafkaConsumerAssignmentFunc(ctx, clusterId, consumerGroupId, consumerId, topicName, partitionId)
}

// GetKafkaConsumerAssignmentCalled returns true if GetKafkaConsumerAssignment was called at least once.
func (m *ConsumerGroupV3Api) GetKafkaConsumerAssignmentCalled() bool {
	m.lockGetKafkaConsumerAssignment.Lock()
	defer m.lockGetKafkaConsumerAssignment.Unlock()

	return len(m.calls.GetKafkaConsumerAssignment) > 0
}

// GetKafkaConsumerAssignmentCalls returns the calls made to GetKafkaConsumerAssignment.
func (m *ConsumerGroupV3Api) GetKafkaConsumerAssignmentCalls() []struct {
	Ctx             context.Context
	ClusterId       string
	ConsumerGroupId string
	ConsumerId      string
	TopicName       string
	PartitionId     int32
} {
	m.lockGetKafkaConsumerAssignment.Lock()
	defer m.lockGetKafkaConsumerAssignment.Unlock()

	return m.calls.GetKafkaConsumerAssignment
}

// GetKafkaConsumerGroup mocks base method by wrapping the associated func.
func (m *ConsumerGroupV3Api) GetKafkaConsumerGroup(ctx context.Context, clusterId, consumerGroupId string) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ConsumerGroupData, *net_http.Response, error) {
	m.lockGetKafkaConsumerGroup.Lock()
	defer m.lockGetKafkaConsumerGroup.Unlock()

	if m.GetKafkaConsumerGroupFunc == nil {
		panic("mocker: ConsumerGroupV3Api.GetKafkaConsumerGroupFunc is nil but ConsumerGroupV3Api.GetKafkaConsumerGroup was called.")
	}

	call := struct {
		Ctx             context.Context
		ClusterId       string
		ConsumerGroupId string
	}{
		Ctx:             ctx,
		ClusterId:       clusterId,
		ConsumerGroupId: consumerGroupId,
	}

	m.calls.GetKafkaConsumerGroup = append(m.calls.GetKafkaConsumerGroup, call)

	return m.GetKafkaConsumerGroupFunc(ctx, clusterId, consumerGroupId)
}

// GetKafkaConsumerGroupCalled returns true if GetKafkaConsumerGroup was called at least once.
func (m *ConsumerGroupV3Api) GetKafkaConsumerGroupCalled() bool {
	m.lockGetKafkaConsumerGroup.Lock()
	defer m.lockGetKafkaConsumerGroup.Unlock()

	return len(m.calls.GetKafkaConsumerGroup) > 0
}

// GetKafkaConsumerGroupCalls returns the calls made to GetKafkaConsumerGroup.
func (m *ConsumerGroupV3Api) GetKafkaConsumerGroupCalls() []struct {
	Ctx             context.Context
	ClusterId       string
	ConsumerGroupId string
} {
	m.lockGetKafkaConsumerGroup.Lock()
	defer m.lockGetKafkaConsumerGroup.Unlock()

	return m.calls.GetKafkaConsumerGroup
}

// GetKafkaConsumerGroupLagSummary mocks base method by wrapping the associated func.
func (m *ConsumerGroupV3Api) GetKafkaConsumerGroupLagSummary(ctx context.Context, clusterId, consumerGroupId string) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ConsumerGroupLagSummaryData, *net_http.Response, error) {
	m.lockGetKafkaConsumerGroupLagSummary.Lock()
	defer m.lockGetKafkaConsumerGroupLagSummary.Unlock()

	if m.GetKafkaConsumerGroupLagSummaryFunc == nil {
		panic("mocker: ConsumerGroupV3Api.GetKafkaConsumerGroupLagSummaryFunc is nil but ConsumerGroupV3Api.GetKafkaConsumerGroupLagSummary was called.")
	}

	call := struct {
		Ctx             context.Context
		ClusterId       string
		ConsumerGroupId string
	}{
		Ctx:             ctx,
		ClusterId:       clusterId,
		ConsumerGroupId: consumerGroupId,
	}

	m.calls.GetKafkaConsumerGroupLagSummary = append(m.calls.GetKafkaConsumerGroupLagSummary, call)

	return m.GetKafkaConsumerGroupLagSummaryFunc(ctx, clusterId, consumerGroupId)
}

// GetKafkaConsumerGroupLagSummaryCalled returns true if GetKafkaConsumerGroupLagSummary was called at least once.
func (m *ConsumerGroupV3Api) GetKafkaConsumerGroupLagSummaryCalled() bool {
	m.lockGetKafkaConsumerGroupLagSummary.Lock()
	defer m.lockGetKafkaConsumerGroupLagSummary.Unlock()

	return len(m.calls.GetKafkaConsumerGroupLagSummary) > 0
}

// GetKafkaConsumerGroupLagSummaryCalls returns the calls made to GetKafkaConsumerGroupLagSummary.
func (m *ConsumerGroupV3Api) GetKafkaConsumerGroupLagSummaryCalls() []struct {
	Ctx             context.Context
	ClusterId       string
	ConsumerGroupId string
} {
	m.lockGetKafkaConsumerGroupLagSummary.Lock()
	defer m.lockGetKafkaConsumerGroupLagSummary.Unlock()

	return m.calls.GetKafkaConsumerGroupLagSummary
}

// ListKafkaConsumerAssignment mocks base method by wrapping the associated func.
func (m *ConsumerGroupV3Api) ListKafkaConsumerAssignment(ctx context.Context, clusterId, consumerGroupId, consumerId string) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ConsumerAssignmentDataList, *net_http.Response, error) {
	m.lockListKafkaConsumerAssignment.Lock()
	defer m.lockListKafkaConsumerAssignment.Unlock()

	if m.ListKafkaConsumerAssignmentFunc == nil {
		panic("mocker: ConsumerGroupV3Api.ListKafkaConsumerAssignmentFunc is nil but ConsumerGroupV3Api.ListKafkaConsumerAssignment was called.")
	}

	call := struct {
		Ctx             context.Context
		ClusterId       string
		ConsumerGroupId string
		ConsumerId      string
	}{
		Ctx:             ctx,
		ClusterId:       clusterId,
		ConsumerGroupId: consumerGroupId,
		ConsumerId:      consumerId,
	}

	m.calls.ListKafkaConsumerAssignment = append(m.calls.ListKafkaConsumerAssignment, call)

	return m.ListKafkaConsumerAssignmentFunc(ctx, clusterId, consumerGroupId, consumerId)
}

// ListKafkaConsumerAssignmentCalled returns true if ListKafkaConsumerAssignment was called at least once.
func (m *ConsumerGroupV3Api) ListKafkaConsumerAssignmentCalled() bool {
	m.lockListKafkaConsumerAssignment.Lock()
	defer m.lockListKafkaConsumerAssignment.Unlock()

	return len(m.calls.ListKafkaConsumerAssignment) > 0
}

// ListKafkaConsumerAssignmentCalls returns the calls made to ListKafkaConsumerAssignment.
func (m *ConsumerGroupV3Api) ListKafkaConsumerAssignmentCalls() []struct {
	Ctx             context.Context
	ClusterId       string
	ConsumerGroupId string
	ConsumerId      string
} {
	m.lockListKafkaConsumerAssignment.Lock()
	defer m.lockListKafkaConsumerAssignment.Unlock()

	return m.calls.ListKafkaConsumerAssignment
}

// ListKafkaConsumerGroups mocks base method by wrapping the associated func.
func (m *ConsumerGroupV3Api) ListKafkaConsumerGroups(ctx context.Context, clusterId string) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ConsumerGroupDataList, *net_http.Response, error) {
	m.lockListKafkaConsumerGroups.Lock()
	defer m.lockListKafkaConsumerGroups.Unlock()

	if m.ListKafkaConsumerGroupsFunc == nil {
		panic("mocker: ConsumerGroupV3Api.ListKafkaConsumerGroupsFunc is nil but ConsumerGroupV3Api.ListKafkaConsumerGroups was called.")
	}

	call := struct {
		Ctx       context.Context
		ClusterId string
	}{
		Ctx:       ctx,
		ClusterId: clusterId,
	}

	m.calls.ListKafkaConsumerGroups = append(m.calls.ListKafkaConsumerGroups, call)

	return m.ListKafkaConsumerGroupsFunc(ctx, clusterId)
}

// ListKafkaConsumerGroupsCalled returns true if ListKafkaConsumerGroups was called at least once.
func (m *ConsumerGroupV3Api) ListKafkaConsumerGroupsCalled() bool {
	m.lockListKafkaConsumerGroups.Lock()
	defer m.lockListKafkaConsumerGroups.Unlock()

	return len(m.calls.ListKafkaConsumerGroups) > 0
}

// ListKafkaConsumerGroupsCalls returns the calls made to ListKafkaConsumerGroups.
func (m *ConsumerGroupV3Api) ListKafkaConsumerGroupsCalls() []struct {
	Ctx       context.Context
	ClusterId string
} {
	m.lockListKafkaConsumerGroups.Lock()
	defer m.lockListKafkaConsumerGroups.Unlock()

	return m.calls.ListKafkaConsumerGroups
}

// ListKafkaConsumerLags mocks base method by wrapping the associated func.
func (m *ConsumerGroupV3Api) ListKafkaConsumerLags(ctx context.Context, clusterId, consumerGroupId string) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ConsumerLagDataList, *net_http.Response, error) {
	m.lockListKafkaConsumerLags.Lock()
	defer m.lockListKafkaConsumerLags.Unlock()

	if m.ListKafkaConsumerLagsFunc == nil {
		panic("mocker: ConsumerGroupV3Api.ListKafkaConsumerLagsFunc is nil but ConsumerGroupV3Api.ListKafkaConsumerLags was called.")
	}

	call := struct {
		Ctx             context.Context
		ClusterId       string
		ConsumerGroupId string
	}{
		Ctx:             ctx,
		ClusterId:       clusterId,
		ConsumerGroupId: consumerGroupId,
	}

	m.calls.ListKafkaConsumerLags = append(m.calls.ListKafkaConsumerLags, call)

	return m.ListKafkaConsumerLagsFunc(ctx, clusterId, consumerGroupId)
}

// ListKafkaConsumerLagsCalled returns true if ListKafkaConsumerLags was called at least once.
func (m *ConsumerGroupV3Api) ListKafkaConsumerLagsCalled() bool {
	m.lockListKafkaConsumerLags.Lock()
	defer m.lockListKafkaConsumerLags.Unlock()

	return len(m.calls.ListKafkaConsumerLags) > 0
}

// ListKafkaConsumerLagsCalls returns the calls made to ListKafkaConsumerLags.
func (m *ConsumerGroupV3Api) ListKafkaConsumerLagsCalls() []struct {
	Ctx             context.Context
	ClusterId       string
	ConsumerGroupId string
} {
	m.lockListKafkaConsumerLags.Lock()
	defer m.lockListKafkaConsumerLags.Unlock()

	return m.calls.ListKafkaConsumerLags
}

// ListKafkaConsumers mocks base method by wrapping the associated func.
func (m *ConsumerGroupV3Api) ListKafkaConsumers(ctx context.Context, clusterId, consumerGroupId string) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ConsumerDataList, *net_http.Response, error) {
	m.lockListKafkaConsumers.Lock()
	defer m.lockListKafkaConsumers.Unlock()

	if m.ListKafkaConsumersFunc == nil {
		panic("mocker: ConsumerGroupV3Api.ListKafkaConsumersFunc is nil but ConsumerGroupV3Api.ListKafkaConsumers was called.")
	}

	call := struct {
		Ctx             context.Context
		ClusterId       string
		ConsumerGroupId string
	}{
		Ctx:             ctx,
		ClusterId:       clusterId,
		ConsumerGroupId: consumerGroupId,
	}

	m.calls.ListKafkaConsumers = append(m.calls.ListKafkaConsumers, call)

	return m.ListKafkaConsumersFunc(ctx, clusterId, consumerGroupId)
}

// ListKafkaConsumersCalled returns true if ListKafkaConsumers was called at least once.
func (m *ConsumerGroupV3Api) ListKafkaConsumersCalled() bool {
	m.lockListKafkaConsumers.Lock()
	defer m.lockListKafkaConsumers.Unlock()

	return len(m.calls.ListKafkaConsumers) > 0
}

// ListKafkaConsumersCalls returns the calls made to ListKafkaConsumers.
func (m *ConsumerGroupV3Api) ListKafkaConsumersCalls() []struct {
	Ctx             context.Context
	ClusterId       string
	ConsumerGroupId string
} {
	m.lockListKafkaConsumers.Lock()
	defer m.lockListKafkaConsumers.Unlock()

	return m.calls.ListKafkaConsumers
}

// Reset resets the calls made to the mocked methods.
func (m *ConsumerGroupV3Api) Reset() {
	m.lockGetKafkaConsumer.Lock()
	m.calls.GetKafkaConsumer = nil
	m.lockGetKafkaConsumer.Unlock()
	m.lockGetKafkaConsumerAssignment.Lock()
	m.calls.GetKafkaConsumerAssignment = nil
	m.lockGetKafkaConsumerAssignment.Unlock()
	m.lockGetKafkaConsumerGroup.Lock()
	m.calls.GetKafkaConsumerGroup = nil
	m.lockGetKafkaConsumerGroup.Unlock()
	m.lockGetKafkaConsumerGroupLagSummary.Lock()
	m.calls.GetKafkaConsumerGroupLagSummary = nil
	m.lockGetKafkaConsumerGroupLagSummary.Unlock()
	m.lockListKafkaConsumerAssignment.Lock()
	m.calls.ListKafkaConsumerAssignment = nil
	m.lockListKafkaConsumerAssignment.Unlock()
	m.lockListKafkaConsumerGroups.Lock()
	m.calls.ListKafkaConsumerGroups = nil
	m.lockListKafkaConsumerGroups.Unlock()
	m.lockListKafkaConsumerLags.Lock()
	m.calls.ListKafkaConsumerLags = nil
	m.lockListKafkaConsumerLags.Unlock()
	m.lockListKafkaConsumers.Lock()
	m.calls.ListKafkaConsumers = nil
	m.lockListKafkaConsumers.Unlock()
}
