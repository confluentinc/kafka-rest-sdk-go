// Code generated by mocker. DO NOT EDIT.
// github.com/travisjeffery/mocker
// Source: ../kafka-rest-sdk-go/kafkarestv3/api_partition_v3.go

package mock

import (
	context "context"
	net_http "net/http"
	sync "sync"

	github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3 "github.com/confluentinc/kafka-rest-sdk-go/kafkarestv3"
)

// PartitionV3Api is a mock of PartitionV3Api interface
type PartitionV3Api struct {
	lockGetKafkaConsumerLag sync.Mutex
	GetKafkaConsumerLagFunc func(ctx context.Context, clusterId, consumerGroupId, topicName string, partitionId int32) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ConsumerLagData, *net_http.Response, error)

	lockGetKafkaPartition sync.Mutex
	GetKafkaPartitionFunc func(ctx context.Context, clusterId, topicName string, partitionId int32) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.PartitionData, *net_http.Response, error)

	lockListKafkaPartitions sync.Mutex
	ListKafkaPartitionsFunc func(ctx context.Context, clusterId, topicName string) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.PartitionDataList, *net_http.Response, error)

	calls struct {
		GetKafkaConsumerLag []struct {
			Ctx             context.Context
			ClusterId       string
			ConsumerGroupId string
			TopicName       string
			PartitionId     int32
		}
		GetKafkaPartition []struct {
			Ctx         context.Context
			ClusterId   string
			TopicName   string
			PartitionId int32
		}
		ListKafkaPartitions []struct {
			Ctx       context.Context
			ClusterId string
			TopicName string
		}
	}
}

// GetKafkaConsumerLag mocks base method by wrapping the associated func.
func (m *PartitionV3Api) GetKafkaConsumerLag(ctx context.Context, clusterId, consumerGroupId, topicName string, partitionId int32) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ConsumerLagData, *net_http.Response, error) {
	m.lockGetKafkaConsumerLag.Lock()
	defer m.lockGetKafkaConsumerLag.Unlock()

	if m.GetKafkaConsumerLagFunc == nil {
		panic("mocker: PartitionV3Api.GetKafkaConsumerLagFunc is nil but PartitionV3Api.GetKafkaConsumerLag was called.")
	}

	call := struct {
		Ctx             context.Context
		ClusterId       string
		ConsumerGroupId string
		TopicName       string
		PartitionId     int32
	}{
		Ctx:             ctx,
		ClusterId:       clusterId,
		ConsumerGroupId: consumerGroupId,
		TopicName:       topicName,
		PartitionId:     partitionId,
	}

	m.calls.GetKafkaConsumerLag = append(m.calls.GetKafkaConsumerLag, call)

	return m.GetKafkaConsumerLagFunc(ctx, clusterId, consumerGroupId, topicName, partitionId)
}

// GetKafkaConsumerLagCalled returns true if GetKafkaConsumerLag was called at least once.
func (m *PartitionV3Api) GetKafkaConsumerLagCalled() bool {
	m.lockGetKafkaConsumerLag.Lock()
	defer m.lockGetKafkaConsumerLag.Unlock()

	return len(m.calls.GetKafkaConsumerLag) > 0
}

// GetKafkaConsumerLagCalls returns the calls made to GetKafkaConsumerLag.
func (m *PartitionV3Api) GetKafkaConsumerLagCalls() []struct {
	Ctx             context.Context
	ClusterId       string
	ConsumerGroupId string
	TopicName       string
	PartitionId     int32
} {
	m.lockGetKafkaConsumerLag.Lock()
	defer m.lockGetKafkaConsumerLag.Unlock()

	return m.calls.GetKafkaConsumerLag
}

// GetKafkaPartition mocks base method by wrapping the associated func.
func (m *PartitionV3Api) GetKafkaPartition(ctx context.Context, clusterId, topicName string, partitionId int32) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.PartitionData, *net_http.Response, error) {
	m.lockGetKafkaPartition.Lock()
	defer m.lockGetKafkaPartition.Unlock()

	if m.GetKafkaPartitionFunc == nil {
		panic("mocker: PartitionV3Api.GetKafkaPartitionFunc is nil but PartitionV3Api.GetKafkaPartition was called.")
	}

	call := struct {
		Ctx         context.Context
		ClusterId   string
		TopicName   string
		PartitionId int32
	}{
		Ctx:         ctx,
		ClusterId:   clusterId,
		TopicName:   topicName,
		PartitionId: partitionId,
	}

	m.calls.GetKafkaPartition = append(m.calls.GetKafkaPartition, call)

	return m.GetKafkaPartitionFunc(ctx, clusterId, topicName, partitionId)
}

// GetKafkaPartitionCalled returns true if GetKafkaPartition was called at least once.
func (m *PartitionV3Api) GetKafkaPartitionCalled() bool {
	m.lockGetKafkaPartition.Lock()
	defer m.lockGetKafkaPartition.Unlock()

	return len(m.calls.GetKafkaPartition) > 0
}

// GetKafkaPartitionCalls returns the calls made to GetKafkaPartition.
func (m *PartitionV3Api) GetKafkaPartitionCalls() []struct {
	Ctx         context.Context
	ClusterId   string
	TopicName   string
	PartitionId int32
} {
	m.lockGetKafkaPartition.Lock()
	defer m.lockGetKafkaPartition.Unlock()

	return m.calls.GetKafkaPartition
}

// ListKafkaPartitions mocks base method by wrapping the associated func.
func (m *PartitionV3Api) ListKafkaPartitions(ctx context.Context, clusterId, topicName string) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.PartitionDataList, *net_http.Response, error) {
	m.lockListKafkaPartitions.Lock()
	defer m.lockListKafkaPartitions.Unlock()

	if m.ListKafkaPartitionsFunc == nil {
		panic("mocker: PartitionV3Api.ListKafkaPartitionsFunc is nil but PartitionV3Api.ListKafkaPartitions was called.")
	}

	call := struct {
		Ctx       context.Context
		ClusterId string
		TopicName string
	}{
		Ctx:       ctx,
		ClusterId: clusterId,
		TopicName: topicName,
	}

	m.calls.ListKafkaPartitions = append(m.calls.ListKafkaPartitions, call)

	return m.ListKafkaPartitionsFunc(ctx, clusterId, topicName)
}

// ListKafkaPartitionsCalled returns true if ListKafkaPartitions was called at least once.
func (m *PartitionV3Api) ListKafkaPartitionsCalled() bool {
	m.lockListKafkaPartitions.Lock()
	defer m.lockListKafkaPartitions.Unlock()

	return len(m.calls.ListKafkaPartitions) > 0
}

// ListKafkaPartitionsCalls returns the calls made to ListKafkaPartitions.
func (m *PartitionV3Api) ListKafkaPartitionsCalls() []struct {
	Ctx       context.Context
	ClusterId string
	TopicName string
} {
	m.lockListKafkaPartitions.Lock()
	defer m.lockListKafkaPartitions.Unlock()

	return m.calls.ListKafkaPartitions
}

// Reset resets the calls made to the mocked methods.
func (m *PartitionV3Api) Reset() {
	m.lockGetKafkaConsumerLag.Lock()
	m.calls.GetKafkaConsumerLag = nil
	m.lockGetKafkaConsumerLag.Unlock()
	m.lockGetKafkaPartition.Lock()
	m.calls.GetKafkaPartition = nil
	m.lockGetKafkaPartition.Unlock()
	m.lockListKafkaPartitions.Lock()
	m.calls.ListKafkaPartitions = nil
	m.lockListKafkaPartitions.Unlock()
}
