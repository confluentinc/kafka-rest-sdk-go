// Code generated by mocker. DO NOT EDIT.
// github.com/travisjeffery/mocker
// Source: ../kafka-rest-sdk-go/kafkarestv3/api_cluster_linking_v3.go

package mock

import (
	context "context"
	net_http "net/http"
	sync "sync"

	github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3 "github.com/confluentinc/kafka-rest-sdk-go/kafkarestv3"
)

// ClusterLinkingV3Api is a mock of ClusterLinkingV3Api interface
type ClusterLinkingV3Api struct {
	lockCreateKafkaLink sync.Mutex
	CreateKafkaLinkFunc func(ctx context.Context, clusterId, linkName string, localVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.CreateKafkaLinkOpts) (*net_http.Response, error)

	lockCreateKafkaMirrorTopic sync.Mutex
	CreateKafkaMirrorTopicFunc func(ctx context.Context, clusterId, linkName string, localVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.CreateKafkaMirrorTopicOpts) (*net_http.Response, error)

	lockDeleteKafkaLink sync.Mutex
	DeleteKafkaLinkFunc func(ctx context.Context, clusterId, linkName string, localVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.DeleteKafkaLinkOpts) (*net_http.Response, error)

	lockDeleteKafkaLinkConfig sync.Mutex
	DeleteKafkaLinkConfigFunc func(ctx context.Context, clusterId, linkName, configName string) (*net_http.Response, error)

	lockGetKafkaLink sync.Mutex
	GetKafkaLinkFunc func(ctx context.Context, clusterId, linkName string) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ListLinksResponseData, *net_http.Response, error)

	lockGetKafkaLinkConfigs sync.Mutex
	GetKafkaLinkConfigsFunc func(ctx context.Context, clusterId, linkName, configName string) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ListLinkConfigsResponseData, *net_http.Response, error)

	lockListKafkaLinkConfigs sync.Mutex
	ListKafkaLinkConfigsFunc func(ctx context.Context, clusterId, linkName string) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ListLinkConfigsResponseDataList, *net_http.Response, error)

	lockListKafkaLinks sync.Mutex
	ListKafkaLinksFunc func(ctx context.Context, clusterId string) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ListLinksResponseDataList, *net_http.Response, error)

	lockListKafkaMirrorTopics sync.Mutex
	ListKafkaMirrorTopicsFunc func(ctx context.Context, clusterId string, localVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ListKafkaMirrorTopicsOpts) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ListMirrorTopicsResponseDataList, *net_http.Response, error)

	lockListKafkaMirrorTopicsUnderLink sync.Mutex
	ListKafkaMirrorTopicsUnderLinkFunc func(ctx context.Context, clusterId, linkName string, localVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ListKafkaMirrorTopicsUnderLinkOpts) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ListMirrorTopicsResponseDataList, *net_http.Response, error)

	lockReadKafkaMirrorTopic sync.Mutex
	ReadKafkaMirrorTopicFunc func(ctx context.Context, clusterId, linkName, mirrorTopicName string) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ListMirrorTopicsResponseData, *net_http.Response, error)

	lockUpdateKafkaLinkConfig sync.Mutex
	UpdateKafkaLinkConfigFunc func(ctx context.Context, clusterId, linkName, configName string, localVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.UpdateKafkaLinkConfigOpts) (*net_http.Response, error)

	lockUpdateKafkaLinkConfigBatch sync.Mutex
	UpdateKafkaLinkConfigBatchFunc func(ctx context.Context, clusterId, linkName string, localVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.UpdateKafkaLinkConfigBatchOpts) (*net_http.Response, error)

	lockUpdateKafkaMirrorTopicsFailover sync.Mutex
	UpdateKafkaMirrorTopicsFailoverFunc func(ctx context.Context, clusterId, linkName string, localVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.UpdateKafkaMirrorTopicsFailoverOpts) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.AlterMirrorStatusResponseDataList, *net_http.Response, error)

	lockUpdateKafkaMirrorTopicsPause sync.Mutex
	UpdateKafkaMirrorTopicsPauseFunc func(ctx context.Context, clusterId, linkName string, localVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.UpdateKafkaMirrorTopicsPauseOpts) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.AlterMirrorStatusResponseDataList, *net_http.Response, error)

	lockUpdateKafkaMirrorTopicsPromote sync.Mutex
	UpdateKafkaMirrorTopicsPromoteFunc func(ctx context.Context, clusterId, linkName string, localVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.UpdateKafkaMirrorTopicsPromoteOpts) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.AlterMirrorStatusResponseDataList, *net_http.Response, error)

	lockUpdateKafkaMirrorTopicsResume sync.Mutex
	UpdateKafkaMirrorTopicsResumeFunc func(ctx context.Context, clusterId, linkName string, localVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.UpdateKafkaMirrorTopicsResumeOpts) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.AlterMirrorStatusResponseDataList, *net_http.Response, error)

	calls struct {
		CreateKafkaLink []struct {
			Ctx               context.Context
			ClusterId         string
			LinkName          string
			LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.CreateKafkaLinkOpts
		}
		CreateKafkaMirrorTopic []struct {
			Ctx               context.Context
			ClusterId         string
			LinkName          string
			LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.CreateKafkaMirrorTopicOpts
		}
		DeleteKafkaLink []struct {
			Ctx               context.Context
			ClusterId         string
			LinkName          string
			LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.DeleteKafkaLinkOpts
		}
		DeleteKafkaLinkConfig []struct {
			Ctx        context.Context
			ClusterId  string
			LinkName   string
			ConfigName string
		}
		GetKafkaLink []struct {
			Ctx       context.Context
			ClusterId string
			LinkName  string
		}
		GetKafkaLinkConfigs []struct {
			Ctx        context.Context
			ClusterId  string
			LinkName   string
			ConfigName string
		}
		ListKafkaLinkConfigs []struct {
			Ctx       context.Context
			ClusterId string
			LinkName  string
		}
		ListKafkaLinks []struct {
			Ctx       context.Context
			ClusterId string
		}
		ListKafkaMirrorTopics []struct {
			Ctx               context.Context
			ClusterId         string
			LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ListKafkaMirrorTopicsOpts
		}
		ListKafkaMirrorTopicsUnderLink []struct {
			Ctx               context.Context
			ClusterId         string
			LinkName          string
			LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ListKafkaMirrorTopicsUnderLinkOpts
		}
		ReadKafkaMirrorTopic []struct {
			Ctx             context.Context
			ClusterId       string
			LinkName        string
			MirrorTopicName string
		}
		UpdateKafkaLinkConfig []struct {
			Ctx               context.Context
			ClusterId         string
			LinkName          string
			ConfigName        string
			LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.UpdateKafkaLinkConfigOpts
		}
		UpdateKafkaLinkConfigBatch []struct {
			Ctx               context.Context
			ClusterId         string
			LinkName          string
			LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.UpdateKafkaLinkConfigBatchOpts
		}
		UpdateKafkaMirrorTopicsFailover []struct {
			Ctx               context.Context
			ClusterId         string
			LinkName          string
			LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.UpdateKafkaMirrorTopicsFailoverOpts
		}
		UpdateKafkaMirrorTopicsPause []struct {
			Ctx               context.Context
			ClusterId         string
			LinkName          string
			LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.UpdateKafkaMirrorTopicsPauseOpts
		}
		UpdateKafkaMirrorTopicsPromote []struct {
			Ctx               context.Context
			ClusterId         string
			LinkName          string
			LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.UpdateKafkaMirrorTopicsPromoteOpts
		}
		UpdateKafkaMirrorTopicsResume []struct {
			Ctx               context.Context
			ClusterId         string
			LinkName          string
			LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.UpdateKafkaMirrorTopicsResumeOpts
		}
	}
}

// CreateKafkaLink mocks base method by wrapping the associated func.
func (m *ClusterLinkingV3Api) CreateKafkaLink(ctx context.Context, clusterId, linkName string, localVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.CreateKafkaLinkOpts) (*net_http.Response, error) {
	m.lockCreateKafkaLink.Lock()
	defer m.lockCreateKafkaLink.Unlock()

	if m.CreateKafkaLinkFunc == nil {
		panic("mocker: ClusterLinkingV3Api.CreateKafkaLinkFunc is nil but ClusterLinkingV3Api.CreateKafkaLink was called.")
	}

	call := struct {
		Ctx               context.Context
		ClusterId         string
		LinkName          string
		LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.CreateKafkaLinkOpts
	}{
		Ctx:               ctx,
		ClusterId:         clusterId,
		LinkName:          linkName,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.CreateKafkaLink = append(m.calls.CreateKafkaLink, call)

	return m.CreateKafkaLinkFunc(ctx, clusterId, linkName, localVarOptionals)
}

// CreateKafkaLinkCalled returns true if CreateKafkaLink was called at least once.
func (m *ClusterLinkingV3Api) CreateKafkaLinkCalled() bool {
	m.lockCreateKafkaLink.Lock()
	defer m.lockCreateKafkaLink.Unlock()

	return len(m.calls.CreateKafkaLink) > 0
}

// CreateKafkaLinkCalls returns the calls made to CreateKafkaLink.
func (m *ClusterLinkingV3Api) CreateKafkaLinkCalls() []struct {
	Ctx               context.Context
	ClusterId         string
	LinkName          string
	LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.CreateKafkaLinkOpts
} {
	m.lockCreateKafkaLink.Lock()
	defer m.lockCreateKafkaLink.Unlock()

	return m.calls.CreateKafkaLink
}

// CreateKafkaMirrorTopic mocks base method by wrapping the associated func.
func (m *ClusterLinkingV3Api) CreateKafkaMirrorTopic(ctx context.Context, clusterId, linkName string, localVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.CreateKafkaMirrorTopicOpts) (*net_http.Response, error) {
	m.lockCreateKafkaMirrorTopic.Lock()
	defer m.lockCreateKafkaMirrorTopic.Unlock()

	if m.CreateKafkaMirrorTopicFunc == nil {
		panic("mocker: ClusterLinkingV3Api.CreateKafkaMirrorTopicFunc is nil but ClusterLinkingV3Api.CreateKafkaMirrorTopic was called.")
	}

	call := struct {
		Ctx               context.Context
		ClusterId         string
		LinkName          string
		LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.CreateKafkaMirrorTopicOpts
	}{
		Ctx:               ctx,
		ClusterId:         clusterId,
		LinkName:          linkName,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.CreateKafkaMirrorTopic = append(m.calls.CreateKafkaMirrorTopic, call)

	return m.CreateKafkaMirrorTopicFunc(ctx, clusterId, linkName, localVarOptionals)
}

// CreateKafkaMirrorTopicCalled returns true if CreateKafkaMirrorTopic was called at least once.
func (m *ClusterLinkingV3Api) CreateKafkaMirrorTopicCalled() bool {
	m.lockCreateKafkaMirrorTopic.Lock()
	defer m.lockCreateKafkaMirrorTopic.Unlock()

	return len(m.calls.CreateKafkaMirrorTopic) > 0
}

// CreateKafkaMirrorTopicCalls returns the calls made to CreateKafkaMirrorTopic.
func (m *ClusterLinkingV3Api) CreateKafkaMirrorTopicCalls() []struct {
	Ctx               context.Context
	ClusterId         string
	LinkName          string
	LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.CreateKafkaMirrorTopicOpts
} {
	m.lockCreateKafkaMirrorTopic.Lock()
	defer m.lockCreateKafkaMirrorTopic.Unlock()

	return m.calls.CreateKafkaMirrorTopic
}

// DeleteKafkaLink mocks base method by wrapping the associated func.
func (m *ClusterLinkingV3Api) DeleteKafkaLink(ctx context.Context, clusterId, linkName string, localVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.DeleteKafkaLinkOpts) (*net_http.Response, error) {
	m.lockDeleteKafkaLink.Lock()
	defer m.lockDeleteKafkaLink.Unlock()

	if m.DeleteKafkaLinkFunc == nil {
		panic("mocker: ClusterLinkingV3Api.DeleteKafkaLinkFunc is nil but ClusterLinkingV3Api.DeleteKafkaLink was called.")
	}

	call := struct {
		Ctx               context.Context
		ClusterId         string
		LinkName          string
		LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.DeleteKafkaLinkOpts
	}{
		Ctx:               ctx,
		ClusterId:         clusterId,
		LinkName:          linkName,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.DeleteKafkaLink = append(m.calls.DeleteKafkaLink, call)

	return m.DeleteKafkaLinkFunc(ctx, clusterId, linkName, localVarOptionals)
}

// DeleteKafkaLinkCalled returns true if DeleteKafkaLink was called at least once.
func (m *ClusterLinkingV3Api) DeleteKafkaLinkCalled() bool {
	m.lockDeleteKafkaLink.Lock()
	defer m.lockDeleteKafkaLink.Unlock()

	return len(m.calls.DeleteKafkaLink) > 0
}

// DeleteKafkaLinkCalls returns the calls made to DeleteKafkaLink.
func (m *ClusterLinkingV3Api) DeleteKafkaLinkCalls() []struct {
	Ctx               context.Context
	ClusterId         string
	LinkName          string
	LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.DeleteKafkaLinkOpts
} {
	m.lockDeleteKafkaLink.Lock()
	defer m.lockDeleteKafkaLink.Unlock()

	return m.calls.DeleteKafkaLink
}

// DeleteKafkaLinkConfig mocks base method by wrapping the associated func.
func (m *ClusterLinkingV3Api) DeleteKafkaLinkConfig(ctx context.Context, clusterId, linkName, configName string) (*net_http.Response, error) {
	m.lockDeleteKafkaLinkConfig.Lock()
	defer m.lockDeleteKafkaLinkConfig.Unlock()

	if m.DeleteKafkaLinkConfigFunc == nil {
		panic("mocker: ClusterLinkingV3Api.DeleteKafkaLinkConfigFunc is nil but ClusterLinkingV3Api.DeleteKafkaLinkConfig was called.")
	}

	call := struct {
		Ctx        context.Context
		ClusterId  string
		LinkName   string
		ConfigName string
	}{
		Ctx:        ctx,
		ClusterId:  clusterId,
		LinkName:   linkName,
		ConfigName: configName,
	}

	m.calls.DeleteKafkaLinkConfig = append(m.calls.DeleteKafkaLinkConfig, call)

	return m.DeleteKafkaLinkConfigFunc(ctx, clusterId, linkName, configName)
}

// DeleteKafkaLinkConfigCalled returns true if DeleteKafkaLinkConfig was called at least once.
func (m *ClusterLinkingV3Api) DeleteKafkaLinkConfigCalled() bool {
	m.lockDeleteKafkaLinkConfig.Lock()
	defer m.lockDeleteKafkaLinkConfig.Unlock()

	return len(m.calls.DeleteKafkaLinkConfig) > 0
}

// DeleteKafkaLinkConfigCalls returns the calls made to DeleteKafkaLinkConfig.
func (m *ClusterLinkingV3Api) DeleteKafkaLinkConfigCalls() []struct {
	Ctx        context.Context
	ClusterId  string
	LinkName   string
	ConfigName string
} {
	m.lockDeleteKafkaLinkConfig.Lock()
	defer m.lockDeleteKafkaLinkConfig.Unlock()

	return m.calls.DeleteKafkaLinkConfig
}

// GetKafkaLink mocks base method by wrapping the associated func.
func (m *ClusterLinkingV3Api) GetKafkaLink(ctx context.Context, clusterId, linkName string) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ListLinksResponseData, *net_http.Response, error) {
	m.lockGetKafkaLink.Lock()
	defer m.lockGetKafkaLink.Unlock()

	if m.GetKafkaLinkFunc == nil {
		panic("mocker: ClusterLinkingV3Api.GetKafkaLinkFunc is nil but ClusterLinkingV3Api.GetKafkaLink was called.")
	}

	call := struct {
		Ctx       context.Context
		ClusterId string
		LinkName  string
	}{
		Ctx:       ctx,
		ClusterId: clusterId,
		LinkName:  linkName,
	}

	m.calls.GetKafkaLink = append(m.calls.GetKafkaLink, call)

	return m.GetKafkaLinkFunc(ctx, clusterId, linkName)
}

// GetKafkaLinkCalled returns true if GetKafkaLink was called at least once.
func (m *ClusterLinkingV3Api) GetKafkaLinkCalled() bool {
	m.lockGetKafkaLink.Lock()
	defer m.lockGetKafkaLink.Unlock()

	return len(m.calls.GetKafkaLink) > 0
}

// GetKafkaLinkCalls returns the calls made to GetKafkaLink.
func (m *ClusterLinkingV3Api) GetKafkaLinkCalls() []struct {
	Ctx       context.Context
	ClusterId string
	LinkName  string
} {
	m.lockGetKafkaLink.Lock()
	defer m.lockGetKafkaLink.Unlock()

	return m.calls.GetKafkaLink
}

// GetKafkaLinkConfigs mocks base method by wrapping the associated func.
func (m *ClusterLinkingV3Api) GetKafkaLinkConfigs(ctx context.Context, clusterId, linkName, configName string) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ListLinkConfigsResponseData, *net_http.Response, error) {
	m.lockGetKafkaLinkConfigs.Lock()
	defer m.lockGetKafkaLinkConfigs.Unlock()

	if m.GetKafkaLinkConfigsFunc == nil {
		panic("mocker: ClusterLinkingV3Api.GetKafkaLinkConfigsFunc is nil but ClusterLinkingV3Api.GetKafkaLinkConfigs was called.")
	}

	call := struct {
		Ctx        context.Context
		ClusterId  string
		LinkName   string
		ConfigName string
	}{
		Ctx:        ctx,
		ClusterId:  clusterId,
		LinkName:   linkName,
		ConfigName: configName,
	}

	m.calls.GetKafkaLinkConfigs = append(m.calls.GetKafkaLinkConfigs, call)

	return m.GetKafkaLinkConfigsFunc(ctx, clusterId, linkName, configName)
}

// GetKafkaLinkConfigsCalled returns true if GetKafkaLinkConfigs was called at least once.
func (m *ClusterLinkingV3Api) GetKafkaLinkConfigsCalled() bool {
	m.lockGetKafkaLinkConfigs.Lock()
	defer m.lockGetKafkaLinkConfigs.Unlock()

	return len(m.calls.GetKafkaLinkConfigs) > 0
}

// GetKafkaLinkConfigsCalls returns the calls made to GetKafkaLinkConfigs.
func (m *ClusterLinkingV3Api) GetKafkaLinkConfigsCalls() []struct {
	Ctx        context.Context
	ClusterId  string
	LinkName   string
	ConfigName string
} {
	m.lockGetKafkaLinkConfigs.Lock()
	defer m.lockGetKafkaLinkConfigs.Unlock()

	return m.calls.GetKafkaLinkConfigs
}

// ListKafkaLinkConfigs mocks base method by wrapping the associated func.
func (m *ClusterLinkingV3Api) ListKafkaLinkConfigs(ctx context.Context, clusterId, linkName string) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ListLinkConfigsResponseDataList, *net_http.Response, error) {
	m.lockListKafkaLinkConfigs.Lock()
	defer m.lockListKafkaLinkConfigs.Unlock()

	if m.ListKafkaLinkConfigsFunc == nil {
		panic("mocker: ClusterLinkingV3Api.ListKafkaLinkConfigsFunc is nil but ClusterLinkingV3Api.ListKafkaLinkConfigs was called.")
	}

	call := struct {
		Ctx       context.Context
		ClusterId string
		LinkName  string
	}{
		Ctx:       ctx,
		ClusterId: clusterId,
		LinkName:  linkName,
	}

	m.calls.ListKafkaLinkConfigs = append(m.calls.ListKafkaLinkConfigs, call)

	return m.ListKafkaLinkConfigsFunc(ctx, clusterId, linkName)
}

// ListKafkaLinkConfigsCalled returns true if ListKafkaLinkConfigs was called at least once.
func (m *ClusterLinkingV3Api) ListKafkaLinkConfigsCalled() bool {
	m.lockListKafkaLinkConfigs.Lock()
	defer m.lockListKafkaLinkConfigs.Unlock()

	return len(m.calls.ListKafkaLinkConfigs) > 0
}

// ListKafkaLinkConfigsCalls returns the calls made to ListKafkaLinkConfigs.
func (m *ClusterLinkingV3Api) ListKafkaLinkConfigsCalls() []struct {
	Ctx       context.Context
	ClusterId string
	LinkName  string
} {
	m.lockListKafkaLinkConfigs.Lock()
	defer m.lockListKafkaLinkConfigs.Unlock()

	return m.calls.ListKafkaLinkConfigs
}

// ListKafkaLinks mocks base method by wrapping the associated func.
func (m *ClusterLinkingV3Api) ListKafkaLinks(ctx context.Context, clusterId string) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ListLinksResponseDataList, *net_http.Response, error) {
	m.lockListKafkaLinks.Lock()
	defer m.lockListKafkaLinks.Unlock()

	if m.ListKafkaLinksFunc == nil {
		panic("mocker: ClusterLinkingV3Api.ListKafkaLinksFunc is nil but ClusterLinkingV3Api.ListKafkaLinks was called.")
	}

	call := struct {
		Ctx       context.Context
		ClusterId string
	}{
		Ctx:       ctx,
		ClusterId: clusterId,
	}

	m.calls.ListKafkaLinks = append(m.calls.ListKafkaLinks, call)

	return m.ListKafkaLinksFunc(ctx, clusterId)
}

// ListKafkaLinksCalled returns true if ListKafkaLinks was called at least once.
func (m *ClusterLinkingV3Api) ListKafkaLinksCalled() bool {
	m.lockListKafkaLinks.Lock()
	defer m.lockListKafkaLinks.Unlock()

	return len(m.calls.ListKafkaLinks) > 0
}

// ListKafkaLinksCalls returns the calls made to ListKafkaLinks.
func (m *ClusterLinkingV3Api) ListKafkaLinksCalls() []struct {
	Ctx       context.Context
	ClusterId string
} {
	m.lockListKafkaLinks.Lock()
	defer m.lockListKafkaLinks.Unlock()

	return m.calls.ListKafkaLinks
}

// ListKafkaMirrorTopics mocks base method by wrapping the associated func.
func (m *ClusterLinkingV3Api) ListKafkaMirrorTopics(ctx context.Context, clusterId string, localVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ListKafkaMirrorTopicsOpts) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ListMirrorTopicsResponseDataList, *net_http.Response, error) {
	m.lockListKafkaMirrorTopics.Lock()
	defer m.lockListKafkaMirrorTopics.Unlock()

	if m.ListKafkaMirrorTopicsFunc == nil {
		panic("mocker: ClusterLinkingV3Api.ListKafkaMirrorTopicsFunc is nil but ClusterLinkingV3Api.ListKafkaMirrorTopics was called.")
	}

	call := struct {
		Ctx               context.Context
		ClusterId         string
		LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ListKafkaMirrorTopicsOpts
	}{
		Ctx:               ctx,
		ClusterId:         clusterId,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.ListKafkaMirrorTopics = append(m.calls.ListKafkaMirrorTopics, call)

	return m.ListKafkaMirrorTopicsFunc(ctx, clusterId, localVarOptionals)
}

// ListKafkaMirrorTopicsCalled returns true if ListKafkaMirrorTopics was called at least once.
func (m *ClusterLinkingV3Api) ListKafkaMirrorTopicsCalled() bool {
	m.lockListKafkaMirrorTopics.Lock()
	defer m.lockListKafkaMirrorTopics.Unlock()

	return len(m.calls.ListKafkaMirrorTopics) > 0
}

// ListKafkaMirrorTopicsCalls returns the calls made to ListKafkaMirrorTopics.
func (m *ClusterLinkingV3Api) ListKafkaMirrorTopicsCalls() []struct {
	Ctx               context.Context
	ClusterId         string
	LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ListKafkaMirrorTopicsOpts
} {
	m.lockListKafkaMirrorTopics.Lock()
	defer m.lockListKafkaMirrorTopics.Unlock()

	return m.calls.ListKafkaMirrorTopics
}

// ListKafkaMirrorTopicsUnderLink mocks base method by wrapping the associated func.
func (m *ClusterLinkingV3Api) ListKafkaMirrorTopicsUnderLink(ctx context.Context, clusterId, linkName string, localVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ListKafkaMirrorTopicsUnderLinkOpts) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ListMirrorTopicsResponseDataList, *net_http.Response, error) {
	m.lockListKafkaMirrorTopicsUnderLink.Lock()
	defer m.lockListKafkaMirrorTopicsUnderLink.Unlock()

	if m.ListKafkaMirrorTopicsUnderLinkFunc == nil {
		panic("mocker: ClusterLinkingV3Api.ListKafkaMirrorTopicsUnderLinkFunc is nil but ClusterLinkingV3Api.ListKafkaMirrorTopicsUnderLink was called.")
	}

	call := struct {
		Ctx               context.Context
		ClusterId         string
		LinkName          string
		LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ListKafkaMirrorTopicsUnderLinkOpts
	}{
		Ctx:               ctx,
		ClusterId:         clusterId,
		LinkName:          linkName,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.ListKafkaMirrorTopicsUnderLink = append(m.calls.ListKafkaMirrorTopicsUnderLink, call)

	return m.ListKafkaMirrorTopicsUnderLinkFunc(ctx, clusterId, linkName, localVarOptionals)
}

// ListKafkaMirrorTopicsUnderLinkCalled returns true if ListKafkaMirrorTopicsUnderLink was called at least once.
func (m *ClusterLinkingV3Api) ListKafkaMirrorTopicsUnderLinkCalled() bool {
	m.lockListKafkaMirrorTopicsUnderLink.Lock()
	defer m.lockListKafkaMirrorTopicsUnderLink.Unlock()

	return len(m.calls.ListKafkaMirrorTopicsUnderLink) > 0
}

// ListKafkaMirrorTopicsUnderLinkCalls returns the calls made to ListKafkaMirrorTopicsUnderLink.
func (m *ClusterLinkingV3Api) ListKafkaMirrorTopicsUnderLinkCalls() []struct {
	Ctx               context.Context
	ClusterId         string
	LinkName          string
	LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ListKafkaMirrorTopicsUnderLinkOpts
} {
	m.lockListKafkaMirrorTopicsUnderLink.Lock()
	defer m.lockListKafkaMirrorTopicsUnderLink.Unlock()

	return m.calls.ListKafkaMirrorTopicsUnderLink
}

// ReadKafkaMirrorTopic mocks base method by wrapping the associated func.
func (m *ClusterLinkingV3Api) ReadKafkaMirrorTopic(ctx context.Context, clusterId, linkName, mirrorTopicName string) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.ListMirrorTopicsResponseData, *net_http.Response, error) {
	m.lockReadKafkaMirrorTopic.Lock()
	defer m.lockReadKafkaMirrorTopic.Unlock()

	if m.ReadKafkaMirrorTopicFunc == nil {
		panic("mocker: ClusterLinkingV3Api.ReadKafkaMirrorTopicFunc is nil but ClusterLinkingV3Api.ReadKafkaMirrorTopic was called.")
	}

	call := struct {
		Ctx             context.Context
		ClusterId       string
		LinkName        string
		MirrorTopicName string
	}{
		Ctx:             ctx,
		ClusterId:       clusterId,
		LinkName:        linkName,
		MirrorTopicName: mirrorTopicName,
	}

	m.calls.ReadKafkaMirrorTopic = append(m.calls.ReadKafkaMirrorTopic, call)

	return m.ReadKafkaMirrorTopicFunc(ctx, clusterId, linkName, mirrorTopicName)
}

// ReadKafkaMirrorTopicCalled returns true if ReadKafkaMirrorTopic was called at least once.
func (m *ClusterLinkingV3Api) ReadKafkaMirrorTopicCalled() bool {
	m.lockReadKafkaMirrorTopic.Lock()
	defer m.lockReadKafkaMirrorTopic.Unlock()

	return len(m.calls.ReadKafkaMirrorTopic) > 0
}

// ReadKafkaMirrorTopicCalls returns the calls made to ReadKafkaMirrorTopic.
func (m *ClusterLinkingV3Api) ReadKafkaMirrorTopicCalls() []struct {
	Ctx             context.Context
	ClusterId       string
	LinkName        string
	MirrorTopicName string
} {
	m.lockReadKafkaMirrorTopic.Lock()
	defer m.lockReadKafkaMirrorTopic.Unlock()

	return m.calls.ReadKafkaMirrorTopic
}

// UpdateKafkaLinkConfig mocks base method by wrapping the associated func.
func (m *ClusterLinkingV3Api) UpdateKafkaLinkConfig(ctx context.Context, clusterId, linkName, configName string, localVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.UpdateKafkaLinkConfigOpts) (*net_http.Response, error) {
	m.lockUpdateKafkaLinkConfig.Lock()
	defer m.lockUpdateKafkaLinkConfig.Unlock()

	if m.UpdateKafkaLinkConfigFunc == nil {
		panic("mocker: ClusterLinkingV3Api.UpdateKafkaLinkConfigFunc is nil but ClusterLinkingV3Api.UpdateKafkaLinkConfig was called.")
	}

	call := struct {
		Ctx               context.Context
		ClusterId         string
		LinkName          string
		ConfigName        string
		LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.UpdateKafkaLinkConfigOpts
	}{
		Ctx:               ctx,
		ClusterId:         clusterId,
		LinkName:          linkName,
		ConfigName:        configName,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.UpdateKafkaLinkConfig = append(m.calls.UpdateKafkaLinkConfig, call)

	return m.UpdateKafkaLinkConfigFunc(ctx, clusterId, linkName, configName, localVarOptionals)
}

// UpdateKafkaLinkConfigCalled returns true if UpdateKafkaLinkConfig was called at least once.
func (m *ClusterLinkingV3Api) UpdateKafkaLinkConfigCalled() bool {
	m.lockUpdateKafkaLinkConfig.Lock()
	defer m.lockUpdateKafkaLinkConfig.Unlock()

	return len(m.calls.UpdateKafkaLinkConfig) > 0
}

// UpdateKafkaLinkConfigCalls returns the calls made to UpdateKafkaLinkConfig.
func (m *ClusterLinkingV3Api) UpdateKafkaLinkConfigCalls() []struct {
	Ctx               context.Context
	ClusterId         string
	LinkName          string
	ConfigName        string
	LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.UpdateKafkaLinkConfigOpts
} {
	m.lockUpdateKafkaLinkConfig.Lock()
	defer m.lockUpdateKafkaLinkConfig.Unlock()

	return m.calls.UpdateKafkaLinkConfig
}

// UpdateKafkaLinkConfigBatch mocks base method by wrapping the associated func.
func (m *ClusterLinkingV3Api) UpdateKafkaLinkConfigBatch(ctx context.Context, clusterId, linkName string, localVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.UpdateKafkaLinkConfigBatchOpts) (*net_http.Response, error) {
	m.lockUpdateKafkaLinkConfigBatch.Lock()
	defer m.lockUpdateKafkaLinkConfigBatch.Unlock()

	if m.UpdateKafkaLinkConfigBatchFunc == nil {
		panic("mocker: ClusterLinkingV3Api.UpdateKafkaLinkConfigBatchFunc is nil but ClusterLinkingV3Api.UpdateKafkaLinkConfigBatch was called.")
	}

	call := struct {
		Ctx               context.Context
		ClusterId         string
		LinkName          string
		LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.UpdateKafkaLinkConfigBatchOpts
	}{
		Ctx:               ctx,
		ClusterId:         clusterId,
		LinkName:          linkName,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.UpdateKafkaLinkConfigBatch = append(m.calls.UpdateKafkaLinkConfigBatch, call)

	return m.UpdateKafkaLinkConfigBatchFunc(ctx, clusterId, linkName, localVarOptionals)
}

// UpdateKafkaLinkConfigBatchCalled returns true if UpdateKafkaLinkConfigBatch was called at least once.
func (m *ClusterLinkingV3Api) UpdateKafkaLinkConfigBatchCalled() bool {
	m.lockUpdateKafkaLinkConfigBatch.Lock()
	defer m.lockUpdateKafkaLinkConfigBatch.Unlock()

	return len(m.calls.UpdateKafkaLinkConfigBatch) > 0
}

// UpdateKafkaLinkConfigBatchCalls returns the calls made to UpdateKafkaLinkConfigBatch.
func (m *ClusterLinkingV3Api) UpdateKafkaLinkConfigBatchCalls() []struct {
	Ctx               context.Context
	ClusterId         string
	LinkName          string
	LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.UpdateKafkaLinkConfigBatchOpts
} {
	m.lockUpdateKafkaLinkConfigBatch.Lock()
	defer m.lockUpdateKafkaLinkConfigBatch.Unlock()

	return m.calls.UpdateKafkaLinkConfigBatch
}

// UpdateKafkaMirrorTopicsFailover mocks base method by wrapping the associated func.
func (m *ClusterLinkingV3Api) UpdateKafkaMirrorTopicsFailover(ctx context.Context, clusterId, linkName string, localVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.UpdateKafkaMirrorTopicsFailoverOpts) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.AlterMirrorStatusResponseDataList, *net_http.Response, error) {
	m.lockUpdateKafkaMirrorTopicsFailover.Lock()
	defer m.lockUpdateKafkaMirrorTopicsFailover.Unlock()

	if m.UpdateKafkaMirrorTopicsFailoverFunc == nil {
		panic("mocker: ClusterLinkingV3Api.UpdateKafkaMirrorTopicsFailoverFunc is nil but ClusterLinkingV3Api.UpdateKafkaMirrorTopicsFailover was called.")
	}

	call := struct {
		Ctx               context.Context
		ClusterId         string
		LinkName          string
		LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.UpdateKafkaMirrorTopicsFailoverOpts
	}{
		Ctx:               ctx,
		ClusterId:         clusterId,
		LinkName:          linkName,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.UpdateKafkaMirrorTopicsFailover = append(m.calls.UpdateKafkaMirrorTopicsFailover, call)

	return m.UpdateKafkaMirrorTopicsFailoverFunc(ctx, clusterId, linkName, localVarOptionals)
}

// UpdateKafkaMirrorTopicsFailoverCalled returns true if UpdateKafkaMirrorTopicsFailover was called at least once.
func (m *ClusterLinkingV3Api) UpdateKafkaMirrorTopicsFailoverCalled() bool {
	m.lockUpdateKafkaMirrorTopicsFailover.Lock()
	defer m.lockUpdateKafkaMirrorTopicsFailover.Unlock()

	return len(m.calls.UpdateKafkaMirrorTopicsFailover) > 0
}

// UpdateKafkaMirrorTopicsFailoverCalls returns the calls made to UpdateKafkaMirrorTopicsFailover.
func (m *ClusterLinkingV3Api) UpdateKafkaMirrorTopicsFailoverCalls() []struct {
	Ctx               context.Context
	ClusterId         string
	LinkName          string
	LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.UpdateKafkaMirrorTopicsFailoverOpts
} {
	m.lockUpdateKafkaMirrorTopicsFailover.Lock()
	defer m.lockUpdateKafkaMirrorTopicsFailover.Unlock()

	return m.calls.UpdateKafkaMirrorTopicsFailover
}

// UpdateKafkaMirrorTopicsPause mocks base method by wrapping the associated func.
func (m *ClusterLinkingV3Api) UpdateKafkaMirrorTopicsPause(ctx context.Context, clusterId, linkName string, localVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.UpdateKafkaMirrorTopicsPauseOpts) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.AlterMirrorStatusResponseDataList, *net_http.Response, error) {
	m.lockUpdateKafkaMirrorTopicsPause.Lock()
	defer m.lockUpdateKafkaMirrorTopicsPause.Unlock()

	if m.UpdateKafkaMirrorTopicsPauseFunc == nil {
		panic("mocker: ClusterLinkingV3Api.UpdateKafkaMirrorTopicsPauseFunc is nil but ClusterLinkingV3Api.UpdateKafkaMirrorTopicsPause was called.")
	}

	call := struct {
		Ctx               context.Context
		ClusterId         string
		LinkName          string
		LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.UpdateKafkaMirrorTopicsPauseOpts
	}{
		Ctx:               ctx,
		ClusterId:         clusterId,
		LinkName:          linkName,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.UpdateKafkaMirrorTopicsPause = append(m.calls.UpdateKafkaMirrorTopicsPause, call)

	return m.UpdateKafkaMirrorTopicsPauseFunc(ctx, clusterId, linkName, localVarOptionals)
}

// UpdateKafkaMirrorTopicsPauseCalled returns true if UpdateKafkaMirrorTopicsPause was called at least once.
func (m *ClusterLinkingV3Api) UpdateKafkaMirrorTopicsPauseCalled() bool {
	m.lockUpdateKafkaMirrorTopicsPause.Lock()
	defer m.lockUpdateKafkaMirrorTopicsPause.Unlock()

	return len(m.calls.UpdateKafkaMirrorTopicsPause) > 0
}

// UpdateKafkaMirrorTopicsPauseCalls returns the calls made to UpdateKafkaMirrorTopicsPause.
func (m *ClusterLinkingV3Api) UpdateKafkaMirrorTopicsPauseCalls() []struct {
	Ctx               context.Context
	ClusterId         string
	LinkName          string
	LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.UpdateKafkaMirrorTopicsPauseOpts
} {
	m.lockUpdateKafkaMirrorTopicsPause.Lock()
	defer m.lockUpdateKafkaMirrorTopicsPause.Unlock()

	return m.calls.UpdateKafkaMirrorTopicsPause
}

// UpdateKafkaMirrorTopicsPromote mocks base method by wrapping the associated func.
func (m *ClusterLinkingV3Api) UpdateKafkaMirrorTopicsPromote(ctx context.Context, clusterId, linkName string, localVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.UpdateKafkaMirrorTopicsPromoteOpts) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.AlterMirrorStatusResponseDataList, *net_http.Response, error) {
	m.lockUpdateKafkaMirrorTopicsPromote.Lock()
	defer m.lockUpdateKafkaMirrorTopicsPromote.Unlock()

	if m.UpdateKafkaMirrorTopicsPromoteFunc == nil {
		panic("mocker: ClusterLinkingV3Api.UpdateKafkaMirrorTopicsPromoteFunc is nil but ClusterLinkingV3Api.UpdateKafkaMirrorTopicsPromote was called.")
	}

	call := struct {
		Ctx               context.Context
		ClusterId         string
		LinkName          string
		LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.UpdateKafkaMirrorTopicsPromoteOpts
	}{
		Ctx:               ctx,
		ClusterId:         clusterId,
		LinkName:          linkName,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.UpdateKafkaMirrorTopicsPromote = append(m.calls.UpdateKafkaMirrorTopicsPromote, call)

	return m.UpdateKafkaMirrorTopicsPromoteFunc(ctx, clusterId, linkName, localVarOptionals)
}

// UpdateKafkaMirrorTopicsPromoteCalled returns true if UpdateKafkaMirrorTopicsPromote was called at least once.
func (m *ClusterLinkingV3Api) UpdateKafkaMirrorTopicsPromoteCalled() bool {
	m.lockUpdateKafkaMirrorTopicsPromote.Lock()
	defer m.lockUpdateKafkaMirrorTopicsPromote.Unlock()

	return len(m.calls.UpdateKafkaMirrorTopicsPromote) > 0
}

// UpdateKafkaMirrorTopicsPromoteCalls returns the calls made to UpdateKafkaMirrorTopicsPromote.
func (m *ClusterLinkingV3Api) UpdateKafkaMirrorTopicsPromoteCalls() []struct {
	Ctx               context.Context
	ClusterId         string
	LinkName          string
	LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.UpdateKafkaMirrorTopicsPromoteOpts
} {
	m.lockUpdateKafkaMirrorTopicsPromote.Lock()
	defer m.lockUpdateKafkaMirrorTopicsPromote.Unlock()

	return m.calls.UpdateKafkaMirrorTopicsPromote
}

// UpdateKafkaMirrorTopicsResume mocks base method by wrapping the associated func.
func (m *ClusterLinkingV3Api) UpdateKafkaMirrorTopicsResume(ctx context.Context, clusterId, linkName string, localVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.UpdateKafkaMirrorTopicsResumeOpts) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.AlterMirrorStatusResponseDataList, *net_http.Response, error) {
	m.lockUpdateKafkaMirrorTopicsResume.Lock()
	defer m.lockUpdateKafkaMirrorTopicsResume.Unlock()

	if m.UpdateKafkaMirrorTopicsResumeFunc == nil {
		panic("mocker: ClusterLinkingV3Api.UpdateKafkaMirrorTopicsResumeFunc is nil but ClusterLinkingV3Api.UpdateKafkaMirrorTopicsResume was called.")
	}

	call := struct {
		Ctx               context.Context
		ClusterId         string
		LinkName          string
		LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.UpdateKafkaMirrorTopicsResumeOpts
	}{
		Ctx:               ctx,
		ClusterId:         clusterId,
		LinkName:          linkName,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.UpdateKafkaMirrorTopicsResume = append(m.calls.UpdateKafkaMirrorTopicsResume, call)

	return m.UpdateKafkaMirrorTopicsResumeFunc(ctx, clusterId, linkName, localVarOptionals)
}

// UpdateKafkaMirrorTopicsResumeCalled returns true if UpdateKafkaMirrorTopicsResume was called at least once.
func (m *ClusterLinkingV3Api) UpdateKafkaMirrorTopicsResumeCalled() bool {
	m.lockUpdateKafkaMirrorTopicsResume.Lock()
	defer m.lockUpdateKafkaMirrorTopicsResume.Unlock()

	return len(m.calls.UpdateKafkaMirrorTopicsResume) > 0
}

// UpdateKafkaMirrorTopicsResumeCalls returns the calls made to UpdateKafkaMirrorTopicsResume.
func (m *ClusterLinkingV3Api) UpdateKafkaMirrorTopicsResumeCalls() []struct {
	Ctx               context.Context
	ClusterId         string
	LinkName          string
	LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.UpdateKafkaMirrorTopicsResumeOpts
} {
	m.lockUpdateKafkaMirrorTopicsResume.Lock()
	defer m.lockUpdateKafkaMirrorTopicsResume.Unlock()

	return m.calls.UpdateKafkaMirrorTopicsResume
}

// Reset resets the calls made to the mocked methods.
func (m *ClusterLinkingV3Api) Reset() {
	m.lockCreateKafkaLink.Lock()
	m.calls.CreateKafkaLink = nil
	m.lockCreateKafkaLink.Unlock()
	m.lockCreateKafkaMirrorTopic.Lock()
	m.calls.CreateKafkaMirrorTopic = nil
	m.lockCreateKafkaMirrorTopic.Unlock()
	m.lockDeleteKafkaLink.Lock()
	m.calls.DeleteKafkaLink = nil
	m.lockDeleteKafkaLink.Unlock()
	m.lockDeleteKafkaLinkConfig.Lock()
	m.calls.DeleteKafkaLinkConfig = nil
	m.lockDeleteKafkaLinkConfig.Unlock()
	m.lockGetKafkaLink.Lock()
	m.calls.GetKafkaLink = nil
	m.lockGetKafkaLink.Unlock()
	m.lockGetKafkaLinkConfigs.Lock()
	m.calls.GetKafkaLinkConfigs = nil
	m.lockGetKafkaLinkConfigs.Unlock()
	m.lockListKafkaLinkConfigs.Lock()
	m.calls.ListKafkaLinkConfigs = nil
	m.lockListKafkaLinkConfigs.Unlock()
	m.lockListKafkaLinks.Lock()
	m.calls.ListKafkaLinks = nil
	m.lockListKafkaLinks.Unlock()
	m.lockListKafkaMirrorTopics.Lock()
	m.calls.ListKafkaMirrorTopics = nil
	m.lockListKafkaMirrorTopics.Unlock()
	m.lockListKafkaMirrorTopicsUnderLink.Lock()
	m.calls.ListKafkaMirrorTopicsUnderLink = nil
	m.lockListKafkaMirrorTopicsUnderLink.Unlock()
	m.lockReadKafkaMirrorTopic.Lock()
	m.calls.ReadKafkaMirrorTopic = nil
	m.lockReadKafkaMirrorTopic.Unlock()
	m.lockUpdateKafkaLinkConfig.Lock()
	m.calls.UpdateKafkaLinkConfig = nil
	m.lockUpdateKafkaLinkConfig.Unlock()
	m.lockUpdateKafkaLinkConfigBatch.Lock()
	m.calls.UpdateKafkaLinkConfigBatch = nil
	m.lockUpdateKafkaLinkConfigBatch.Unlock()
	m.lockUpdateKafkaMirrorTopicsFailover.Lock()
	m.calls.UpdateKafkaMirrorTopicsFailover = nil
	m.lockUpdateKafkaMirrorTopicsFailover.Unlock()
	m.lockUpdateKafkaMirrorTopicsPause.Lock()
	m.calls.UpdateKafkaMirrorTopicsPause = nil
	m.lockUpdateKafkaMirrorTopicsPause.Unlock()
	m.lockUpdateKafkaMirrorTopicsPromote.Lock()
	m.calls.UpdateKafkaMirrorTopicsPromote = nil
	m.lockUpdateKafkaMirrorTopicsPromote.Unlock()
	m.lockUpdateKafkaMirrorTopicsResume.Lock()
	m.calls.UpdateKafkaMirrorTopicsResume = nil
	m.lockUpdateKafkaMirrorTopicsResume.Unlock()
}
