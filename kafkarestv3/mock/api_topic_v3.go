// Code generated by mocker. DO NOT EDIT.
// github.com/travisjeffery/mocker
// Source: ../kafka-rest-sdk-go/kafkarestv3/api_topic_v3.go

package mock

import (
	context "context"
	net_http "net/http"
	sync "sync"

	github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3 "github.com/confluentinc/kafka-rest-sdk-go/kafkarestv3"
)

// TopicV3Api is a mock of TopicV3Api interface
type TopicV3Api struct {
	lockCreateKafkaTopic sync.Mutex
	CreateKafkaTopicFunc func(ctx context.Context, clusterId string, localVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.CreateKafkaTopicOpts) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.TopicData, *net_http.Response, error)

	lockDeleteKafkaTopic sync.Mutex
	DeleteKafkaTopicFunc func(ctx context.Context, clusterId, topicName string) (*net_http.Response, error)

	lockGetKafkaTopic sync.Mutex
	GetKafkaTopicFunc func(ctx context.Context, clusterId, topicName string) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.TopicData, *net_http.Response, error)

	lockListKafkaTopics sync.Mutex
	ListKafkaTopicsFunc func(ctx context.Context, clusterId string) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.TopicDataList, *net_http.Response, error)

	calls struct {
		CreateKafkaTopic []struct {
			Ctx               context.Context
			ClusterId         string
			LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.CreateKafkaTopicOpts
		}
		DeleteKafkaTopic []struct {
			Ctx       context.Context
			ClusterId string
			TopicName string
		}
		GetKafkaTopic []struct {
			Ctx       context.Context
			ClusterId string
			TopicName string
		}
		ListKafkaTopics []struct {
			Ctx       context.Context
			ClusterId string
		}
	}
}

// CreateKafkaTopic mocks base method by wrapping the associated func.
func (m *TopicV3Api) CreateKafkaTopic(ctx context.Context, clusterId string, localVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.CreateKafkaTopicOpts) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.TopicData, *net_http.Response, error) {
	m.lockCreateKafkaTopic.Lock()
	defer m.lockCreateKafkaTopic.Unlock()

	if m.CreateKafkaTopicFunc == nil {
		panic("mocker: TopicV3Api.CreateKafkaTopicFunc is nil but TopicV3Api.CreateKafkaTopic was called.")
	}

	call := struct {
		Ctx               context.Context
		ClusterId         string
		LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.CreateKafkaTopicOpts
	}{
		Ctx:               ctx,
		ClusterId:         clusterId,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.CreateKafkaTopic = append(m.calls.CreateKafkaTopic, call)

	return m.CreateKafkaTopicFunc(ctx, clusterId, localVarOptionals)
}

// CreateKafkaTopicCalled returns true if CreateKafkaTopic was called at least once.
func (m *TopicV3Api) CreateKafkaTopicCalled() bool {
	m.lockCreateKafkaTopic.Lock()
	defer m.lockCreateKafkaTopic.Unlock()

	return len(m.calls.CreateKafkaTopic) > 0
}

// CreateKafkaTopicCalls returns the calls made to CreateKafkaTopic.
func (m *TopicV3Api) CreateKafkaTopicCalls() []struct {
	Ctx               context.Context
	ClusterId         string
	LocalVarOptionals *github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.CreateKafkaTopicOpts
} {
	m.lockCreateKafkaTopic.Lock()
	defer m.lockCreateKafkaTopic.Unlock()

	return m.calls.CreateKafkaTopic
}

// DeleteKafkaTopic mocks base method by wrapping the associated func.
func (m *TopicV3Api) DeleteKafkaTopic(ctx context.Context, clusterId, topicName string) (*net_http.Response, error) {
	m.lockDeleteKafkaTopic.Lock()
	defer m.lockDeleteKafkaTopic.Unlock()

	if m.DeleteKafkaTopicFunc == nil {
		panic("mocker: TopicV3Api.DeleteKafkaTopicFunc is nil but TopicV3Api.DeleteKafkaTopic was called.")
	}

	call := struct {
		Ctx       context.Context
		ClusterId string
		TopicName string
	}{
		Ctx:       ctx,
		ClusterId: clusterId,
		TopicName: topicName,
	}

	m.calls.DeleteKafkaTopic = append(m.calls.DeleteKafkaTopic, call)

	return m.DeleteKafkaTopicFunc(ctx, clusterId, topicName)
}

// DeleteKafkaTopicCalled returns true if DeleteKafkaTopic was called at least once.
func (m *TopicV3Api) DeleteKafkaTopicCalled() bool {
	m.lockDeleteKafkaTopic.Lock()
	defer m.lockDeleteKafkaTopic.Unlock()

	return len(m.calls.DeleteKafkaTopic) > 0
}

// DeleteKafkaTopicCalls returns the calls made to DeleteKafkaTopic.
func (m *TopicV3Api) DeleteKafkaTopicCalls() []struct {
	Ctx       context.Context
	ClusterId string
	TopicName string
} {
	m.lockDeleteKafkaTopic.Lock()
	defer m.lockDeleteKafkaTopic.Unlock()

	return m.calls.DeleteKafkaTopic
}

// GetKafkaTopic mocks base method by wrapping the associated func.
func (m *TopicV3Api) GetKafkaTopic(ctx context.Context, clusterId, topicName string) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.TopicData, *net_http.Response, error) {
	m.lockGetKafkaTopic.Lock()
	defer m.lockGetKafkaTopic.Unlock()

	if m.GetKafkaTopicFunc == nil {
		panic("mocker: TopicV3Api.GetKafkaTopicFunc is nil but TopicV3Api.GetKafkaTopic was called.")
	}

	call := struct {
		Ctx       context.Context
		ClusterId string
		TopicName string
	}{
		Ctx:       ctx,
		ClusterId: clusterId,
		TopicName: topicName,
	}

	m.calls.GetKafkaTopic = append(m.calls.GetKafkaTopic, call)

	return m.GetKafkaTopicFunc(ctx, clusterId, topicName)
}

// GetKafkaTopicCalled returns true if GetKafkaTopic was called at least once.
func (m *TopicV3Api) GetKafkaTopicCalled() bool {
	m.lockGetKafkaTopic.Lock()
	defer m.lockGetKafkaTopic.Unlock()

	return len(m.calls.GetKafkaTopic) > 0
}

// GetKafkaTopicCalls returns the calls made to GetKafkaTopic.
func (m *TopicV3Api) GetKafkaTopicCalls() []struct {
	Ctx       context.Context
	ClusterId string
	TopicName string
} {
	m.lockGetKafkaTopic.Lock()
	defer m.lockGetKafkaTopic.Unlock()

	return m.calls.GetKafkaTopic
}

// ListKafkaTopics mocks base method by wrapping the associated func.
func (m *TopicV3Api) ListKafkaTopics(ctx context.Context, clusterId string) (github_com_confluentinc_kafka_rest_sdk_go_kafkarestv3.TopicDataList, *net_http.Response, error) {
	m.lockListKafkaTopics.Lock()
	defer m.lockListKafkaTopics.Unlock()

	if m.ListKafkaTopicsFunc == nil {
		panic("mocker: TopicV3Api.ListKafkaTopicsFunc is nil but TopicV3Api.ListKafkaTopics was called.")
	}

	call := struct {
		Ctx       context.Context
		ClusterId string
	}{
		Ctx:       ctx,
		ClusterId: clusterId,
	}

	m.calls.ListKafkaTopics = append(m.calls.ListKafkaTopics, call)

	return m.ListKafkaTopicsFunc(ctx, clusterId)
}

// ListKafkaTopicsCalled returns true if ListKafkaTopics was called at least once.
func (m *TopicV3Api) ListKafkaTopicsCalled() bool {
	m.lockListKafkaTopics.Lock()
	defer m.lockListKafkaTopics.Unlock()

	return len(m.calls.ListKafkaTopics) > 0
}

// ListKafkaTopicsCalls returns the calls made to ListKafkaTopics.
func (m *TopicV3Api) ListKafkaTopicsCalls() []struct {
	Ctx       context.Context
	ClusterId string
} {
	m.lockListKafkaTopics.Lock()
	defer m.lockListKafkaTopics.Unlock()

	return m.calls.ListKafkaTopics
}

// Reset resets the calls made to the mocked methods.
func (m *TopicV3Api) Reset() {
	m.lockCreateKafkaTopic.Lock()
	m.calls.CreateKafkaTopic = nil
	m.lockCreateKafkaTopic.Unlock()
	m.lockDeleteKafkaTopic.Lock()
	m.calls.DeleteKafkaTopic = nil
	m.lockDeleteKafkaTopic.Unlock()
	m.lockGetKafkaTopic.Lock()
	m.calls.GetKafkaTopic = nil
	m.lockGetKafkaTopic.Unlock()
	m.lockListKafkaTopics.Lock()
	m.calls.ListKafkaTopics = nil
	m.lockListKafkaTopics.Unlock()
}
