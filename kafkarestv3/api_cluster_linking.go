// Copyright 2021 Confluent Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*
 * Kafka HTTP API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 3.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package kafkarestv3

import (
	_context "context"
	"github.com/antihax/optional"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

type ClusterLinkingApi interface {

	/*
	 * ClustersClusterIdLinksGet List all cluster links in the dest cluster
	 *
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param clusterId The Kafka cluster ID.
	 * @return ListLinksResponseDataList
	 */
	ClustersClusterIdLinksGet(ctx _context.Context, clusterId string) (ListLinksResponseDataList, *_nethttp.Response, error)

	/*
	 * ClustersClusterIdLinksLinkNameConfigsConfigNameDelete Reset the given config to default value
	 *
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param clusterId The Kafka cluster ID.
	 * @param linkName The link name
	 * @param configName The link config name
	 */
	ClustersClusterIdLinksLinkNameConfigsConfigNameDelete(ctx _context.Context, clusterId string, linkName string, configName string) (*_nethttp.Response, error)

	/*
	 * ClustersClusterIdLinksLinkNameConfigsConfigNameGet Describe the config under the cluster link
	 *
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param clusterId The Kafka cluster ID.
	 * @param linkName The link name
	 * @param configName The link config name
	 * @return ListLinkConfigsResponseData
	 */
	ClustersClusterIdLinksLinkNameConfigsConfigNameGet(ctx _context.Context, clusterId string, linkName string, configName string) (ListLinkConfigsResponseData, *_nethttp.Response, error)

	/*
	 * ClustersClusterIdLinksLinkNameConfigsConfigNamePut Alter the config under the cluster link
	 *
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param clusterId The Kafka cluster ID.
	 * @param linkName The link name
	 * @param configName The link config name
	 * @param optional nil or *ClustersClusterIdLinksLinkNameConfigsConfigNamePutOpts - Optional Parameters:
	 * @param "UpdateLinkConfigRequestData" (optional.Interface of UpdateLinkConfigRequestData) -  Link config value to update
	 */
	ClustersClusterIdLinksLinkNameConfigsConfigNamePut(ctx _context.Context, clusterId string, linkName string, configName string, localVarOptionals *ClustersClusterIdLinksLinkNameConfigsConfigNamePutOpts) (*_nethttp.Response, error)

	/*
	 * ClustersClusterIdLinksLinkNameConfigsGet List all configs of the cluster link
	 *
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param clusterId The Kafka cluster ID.
	 * @param linkName The link name
	 * @return ListLinkConfigsResponseDataList
	 */
	ClustersClusterIdLinksLinkNameConfigsGet(ctx _context.Context, clusterId string, linkName string) (ListLinkConfigsResponseDataList, *_nethttp.Response, error)

	/*
	 * ClustersClusterIdLinksLinkNameConfigsalterPost Batch Alter Topic Configs
	 *
	 * Batch Alter Link Configs
	 *
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param clusterId The Kafka cluster ID.
	 * @param linkName The link name
	 * @param optional nil or *ClustersClusterIdLinksLinkNameConfigsalterPostOpts - Optional Parameters:
	 * @param "ValidateOnly" (optional.Bool) -  To validate the action can be performed successfully or not. Default: false
	 * @param "AlterConfigBatchRequestData" (optional.Interface of AlterConfigBatchRequestData) -
	 */
	ClustersClusterIdLinksLinkNameConfigsalterPost(ctx _context.Context, clusterId string, linkName string, localVarOptionals *ClustersClusterIdLinksLinkNameConfigsalterPostOpts) (*_nethttp.Response, error)

	/*
	 * ClustersClusterIdLinksLinkNameDelete Delete the cluster link
	 *
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param clusterId The Kafka cluster ID.
	 * @param linkName The link name
	 * @param optional nil or *ClustersClusterIdLinksLinkNameDeleteOpts - Optional Parameters:
	 * @param "Force" (optional.Bool) -  Force the action. Default: false
	 * @param "ValidateOnly" (optional.Bool) -  To validate the action can be performed successfully or not. Default: false
	 */
	ClustersClusterIdLinksLinkNameDelete(ctx _context.Context, clusterId string, linkName string, localVarOptionals *ClustersClusterIdLinksLinkNameDeleteOpts) (*_nethttp.Response, error)

	/*
	 * ClustersClusterIdLinksLinkNameGet Describe the cluster link
	 *
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param clusterId The Kafka cluster ID.
	 * @param linkName The link name
	 * @return ListLinksResponseData
	 */
	ClustersClusterIdLinksLinkNameGet(ctx _context.Context, clusterId string, linkName string) (ListLinksResponseData, *_nethttp.Response, error)

	/*
	 * ClustersClusterIdLinksLinkNameMirrorsGet List mirror topics
	 *
	 * List all mirror topics under the link
	 *
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param clusterId The Kafka cluster ID.
	 * @param linkName The link name
	 * @param optional nil or *ClustersClusterIdLinksLinkNameMirrorsGetOpts - Optional Parameters:
	 * @param "MirrorStatus" (optional.Interface of MirrorTopicStatus) -  The status of the mirror topic. If not specified, all mirror topics will be returned.
	 * @return ListMirrorTopicsResponseDataList
	 */
	ClustersClusterIdLinksLinkNameMirrorsGet(ctx _context.Context, clusterId string, linkName string, localVarOptionals *ClustersClusterIdLinksLinkNameMirrorsGetOpts) (ListMirrorTopicsResponseDataList, *_nethttp.Response, error)

	/*
	 * ClustersClusterIdLinksLinkNameMirrorsMirrorTopicNameGet Describe the mirror topic
	 *
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param clusterId The Kafka cluster ID.
	 * @param linkName The link name
	 * @param mirrorTopicName Cluster Linking mirror topic name
	 * @return ListMirrorTopicsResponseData
	 */
	ClustersClusterIdLinksLinkNameMirrorsMirrorTopicNameGet(ctx _context.Context, clusterId string, linkName string, mirrorTopicName string) (ListMirrorTopicsResponseData, *_nethttp.Response, error)

	/*
	 * ClustersClusterIdLinksLinkNameMirrorsPost Create a mirror topic
	 *
	 * Create a topic in the destination cluster mirroring a topic in the source cluster
	 *
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param clusterId The Kafka cluster ID.
	 * @param linkName The link name
	 * @param optional nil or *ClustersClusterIdLinksLinkNameMirrorsPostOpts - Optional Parameters:
	 * @param "CreateMirrorTopicRequestData" (optional.Interface of CreateMirrorTopicRequestData) -  Name and configs of the topics mirroring from and mirroring to
	 */
	ClustersClusterIdLinksLinkNameMirrorsPost(ctx _context.Context, clusterId string, linkName string, localVarOptionals *ClustersClusterIdLinksLinkNameMirrorsPostOpts) (*_nethttp.Response, error)

	/*
	 * ClustersClusterIdLinksLinkNameMirrorsfailoverPost Failover the mirror topics
	 *
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param clusterId The Kafka cluster ID.
	 * @param linkName The link name
	 * @param optional nil or *ClustersClusterIdLinksLinkNameMirrorsfailoverPostOpts - Optional Parameters:
	 * @param "ValidateOnly" (optional.Bool) -  To validate the action can be performed successfully or not. Default: false
	 * @param "AlterMirrorsRequestData" (optional.Interface of AlterMirrorsRequestData) -  Name of the topics to apply the changes
	 * @return AlterMirrorStatusResponseDataList
	 */
	ClustersClusterIdLinksLinkNameMirrorsfailoverPost(ctx _context.Context, clusterId string, linkName string, localVarOptionals *ClustersClusterIdLinksLinkNameMirrorsfailoverPostOpts) (AlterMirrorStatusResponseDataList, *_nethttp.Response, error)

	/*
	 * ClustersClusterIdLinksLinkNameMirrorspausePost Pause the mirror topics
	 *
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param clusterId The Kafka cluster ID.
	 * @param linkName The link name
	 * @param optional nil or *ClustersClusterIdLinksLinkNameMirrorspausePostOpts - Optional Parameters:
	 * @param "ValidateOnly" (optional.Bool) -  To validate the action can be performed successfully or not. Default: false
	 * @param "AlterMirrorsRequestData" (optional.Interface of AlterMirrorsRequestData) -  Name of the topics to apply the changes
	 * @return AlterMirrorStatusResponseDataList
	 */
	ClustersClusterIdLinksLinkNameMirrorspausePost(ctx _context.Context, clusterId string, linkName string, localVarOptionals *ClustersClusterIdLinksLinkNameMirrorspausePostOpts) (AlterMirrorStatusResponseDataList, *_nethttp.Response, error)

	/*
	 * ClustersClusterIdLinksLinkNameMirrorspromotePost Promote the mirror topics
	 *
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param clusterId The Kafka cluster ID.
	 * @param linkName The link name
	 * @param optional nil or *ClustersClusterIdLinksLinkNameMirrorspromotePostOpts - Optional Parameters:
	 * @param "ValidateOnly" (optional.Bool) -  To validate the action can be performed successfully or not. Default: false
	 * @param "AlterMirrorsRequestData" (optional.Interface of AlterMirrorsRequestData) -  Name of the topics to apply the changes
	 * @return AlterMirrorStatusResponseDataList
	 */
	ClustersClusterIdLinksLinkNameMirrorspromotePost(ctx _context.Context, clusterId string, linkName string, localVarOptionals *ClustersClusterIdLinksLinkNameMirrorspromotePostOpts) (AlterMirrorStatusResponseDataList, *_nethttp.Response, error)

	/*
	 * ClustersClusterIdLinksLinkNameMirrorsresumePost Resume the mirror topics
	 *
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param clusterId The Kafka cluster ID.
	 * @param linkName The link name
	 * @param optional nil or *ClustersClusterIdLinksLinkNameMirrorsresumePostOpts - Optional Parameters:
	 * @param "ValidateOnly" (optional.Bool) -  To validate the action can be performed successfully or not. Default: false
	 * @param "AlterMirrorsRequestData" (optional.Interface of AlterMirrorsRequestData) -  Name of the topics to apply the changes
	 * @return AlterMirrorStatusResponseDataList
	 */
	ClustersClusterIdLinksLinkNameMirrorsresumePost(ctx _context.Context, clusterId string, linkName string, localVarOptionals *ClustersClusterIdLinksLinkNameMirrorsresumePostOpts) (AlterMirrorStatusResponseDataList, *_nethttp.Response, error)

	/*
	 * ClustersClusterIdLinksMirrorsGet List mirror topics
	 *
	 * List all mirror topics in the cluster
	 *
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param clusterId The Kafka cluster ID.
	 * @param optional nil or *ClustersClusterIdLinksMirrorsGetOpts - Optional Parameters:
	 * @param "MirrorStatus" (optional.Interface of MirrorTopicStatus) -  The status of the mirror topic. If not specified, all mirror topics will be returned.
	 * @return ListMirrorTopicsResponseDataList
	 */
	ClustersClusterIdLinksMirrorsGet(ctx _context.Context, clusterId string, localVarOptionals *ClustersClusterIdLinksMirrorsGetOpts) (ListMirrorTopicsResponseDataList, *_nethttp.Response, error)

	/*
	 * ClustersClusterIdLinksPost Create a cluster link
	 *
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param clusterId The Kafka cluster ID.
	 * @param linkName The link name
	 * @param optional nil or *ClustersClusterIdLinksPostOpts - Optional Parameters:
	 * @param "ValidateOnly" (optional.Bool) -  To validate the action can be performed successfully or not. Default: false
	 * @param "ValidateLink" (optional.Bool) -  To synchronously validate that the source cluster ID is expected and the dest cluster has the permission to read topics in the source cluster. Default: true
	 * @param "CreateLinkRequestData" (optional.Interface of CreateLinkRequestData) -  Create a cluster link
	 */
	ClustersClusterIdLinksPost(ctx _context.Context, clusterId string, linkName string, localVarOptionals *ClustersClusterIdLinksPostOpts) (*_nethttp.Response, error)
}

// ClusterLinkingApiService ClusterLinkingApi service
type ClusterLinkingApiService service

/*
 * ClustersClusterIdLinksGet List all cluster links in the dest cluster
 *
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param clusterId The Kafka cluster ID.
 * @return ListLinksResponseDataList
 */
func (a *ClusterLinkingApiService) ClustersClusterIdLinksGet(ctx _context.Context, clusterId string) (ListLinksResponseDataList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ListLinksResponseDataList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/clusters/{cluster_id}/links"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(clusterId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
 * ClustersClusterIdLinksLinkNameConfigsConfigNameDelete Reset the given config to default value
 *
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param clusterId The Kafka cluster ID.
 * @param linkName The link name
 * @param configName The link config name
 */
func (a *ClusterLinkingApiService) ClustersClusterIdLinksLinkNameConfigsConfigNameDelete(ctx _context.Context, clusterId string, linkName string, configName string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/clusters/{cluster_id}/links/{link_name}/configs/{config_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(clusterId, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"link_name"+"}", _neturl.PathEscape(parameterToString(linkName, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"config_name"+"}", _neturl.PathEscape(parameterToString(configName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
 * ClustersClusterIdLinksLinkNameConfigsConfigNameGet Describe the config under the cluster link
 *
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param clusterId The Kafka cluster ID.
 * @param linkName The link name
 * @param configName The link config name
 * @return ListLinkConfigsResponseData
 */
func (a *ClusterLinkingApiService) ClustersClusterIdLinksLinkNameConfigsConfigNameGet(ctx _context.Context, clusterId string, linkName string, configName string) (ListLinkConfigsResponseData, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ListLinkConfigsResponseData
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/clusters/{cluster_id}/links/{link_name}/configs/{config_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(clusterId, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"link_name"+"}", _neturl.PathEscape(parameterToString(linkName, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"config_name"+"}", _neturl.PathEscape(parameterToString(configName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ClustersClusterIdLinksLinkNameConfigsConfigNamePutOpts Optional parameters for the method 'ClustersClusterIdLinksLinkNameConfigsConfigNamePut'
type ClustersClusterIdLinksLinkNameConfigsConfigNamePutOpts struct {
	UpdateLinkConfigRequestData optional.Interface
}

/*
 * ClustersClusterIdLinksLinkNameConfigsConfigNamePut Alter the config under the cluster link
 *
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param clusterId The Kafka cluster ID.
 * @param linkName The link name
 * @param configName The link config name
 * @param optional nil or *ClustersClusterIdLinksLinkNameConfigsConfigNamePutOpts - Optional Parameters:
 * @param "UpdateLinkConfigRequestData" (optional.Interface of UpdateLinkConfigRequestData) -  Link config value to update
 */
func (a *ClusterLinkingApiService) ClustersClusterIdLinksLinkNameConfigsConfigNamePut(ctx _context.Context, clusterId string, linkName string, configName string, localVarOptionals *ClustersClusterIdLinksLinkNameConfigsConfigNamePutOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/clusters/{cluster_id}/links/{link_name}/configs/{config_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(clusterId, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"link_name"+"}", _neturl.PathEscape(parameterToString(linkName, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"config_name"+"}", _neturl.PathEscape(parameterToString(configName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.UpdateLinkConfigRequestData.IsSet() {
		localVarOptionalUpdateLinkConfigRequestData, localVarOptionalUpdateLinkConfigRequestDataok := localVarOptionals.UpdateLinkConfigRequestData.Value().(UpdateLinkConfigRequestData)
		if !localVarOptionalUpdateLinkConfigRequestDataok {
			return nil, reportError("updateLinkConfigRequestData should be UpdateLinkConfigRequestData")
		}
		localVarPostBody = &localVarOptionalUpdateLinkConfigRequestData
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
 * ClustersClusterIdLinksLinkNameConfigsGet List all configs of the cluster link
 *
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param clusterId The Kafka cluster ID.
 * @param linkName The link name
 * @return ListLinkConfigsResponseDataList
 */
func (a *ClusterLinkingApiService) ClustersClusterIdLinksLinkNameConfigsGet(ctx _context.Context, clusterId string, linkName string) (ListLinkConfigsResponseDataList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ListLinkConfigsResponseDataList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/clusters/{cluster_id}/links/{link_name}/configs"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(clusterId, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"link_name"+"}", _neturl.PathEscape(parameterToString(linkName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ClustersClusterIdLinksLinkNameConfigsalterPostOpts Optional parameters for the method 'ClustersClusterIdLinksLinkNameConfigsalterPost'
type ClustersClusterIdLinksLinkNameConfigsalterPostOpts struct {
	ValidateOnly                optional.Bool
	AlterConfigBatchRequestData optional.Interface
}

/*
 * ClustersClusterIdLinksLinkNameConfigsalterPost Batch Alter Topic Configs
 *
 * Batch Alter Link Configs
 *
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param clusterId The Kafka cluster ID.
 * @param linkName The link name
 * @param optional nil or *ClustersClusterIdLinksLinkNameConfigsalterPostOpts - Optional Parameters:
 * @param "ValidateOnly" (optional.Bool) -  To validate the action can be performed successfully or not. Default: false
 * @param "AlterConfigBatchRequestData" (optional.Interface of AlterConfigBatchRequestData) -
 */
func (a *ClusterLinkingApiService) ClustersClusterIdLinksLinkNameConfigsalterPost(ctx _context.Context, clusterId string, linkName string, localVarOptionals *ClustersClusterIdLinksLinkNameConfigsalterPostOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/clusters/{cluster_id}/links/{link_name}/configs:alter"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(clusterId, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"link_name"+"}", _neturl.PathEscape(parameterToString(linkName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.ValidateOnly.IsSet() {
		localVarQueryParams.Add("validate_only", parameterToString(localVarOptionals.ValidateOnly.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.AlterConfigBatchRequestData.IsSet() {
		localVarOptionalAlterConfigBatchRequestData, localVarOptionalAlterConfigBatchRequestDataok := localVarOptionals.AlterConfigBatchRequestData.Value().(AlterConfigBatchRequestData)
		if !localVarOptionalAlterConfigBatchRequestDataok {
			return nil, reportError("alterConfigBatchRequestData should be AlterConfigBatchRequestData")
		}
		localVarPostBody = &localVarOptionalAlterConfigBatchRequestData
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// ClustersClusterIdLinksLinkNameDeleteOpts Optional parameters for the method 'ClustersClusterIdLinksLinkNameDelete'
type ClustersClusterIdLinksLinkNameDeleteOpts struct {
	Force        optional.Bool
	ValidateOnly optional.Bool
}

/*
 * ClustersClusterIdLinksLinkNameDelete Delete the cluster link
 *
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param clusterId The Kafka cluster ID.
 * @param linkName The link name
 * @param optional nil or *ClustersClusterIdLinksLinkNameDeleteOpts - Optional Parameters:
 * @param "Force" (optional.Bool) -  Force the action. Default: false
 * @param "ValidateOnly" (optional.Bool) -  To validate the action can be performed successfully or not. Default: false
 */
func (a *ClusterLinkingApiService) ClustersClusterIdLinksLinkNameDelete(ctx _context.Context, clusterId string, linkName string, localVarOptionals *ClustersClusterIdLinksLinkNameDeleteOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/clusters/{cluster_id}/links/{link_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(clusterId, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"link_name"+"}", _neturl.PathEscape(parameterToString(linkName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Force.IsSet() {
		localVarQueryParams.Add("force", parameterToString(localVarOptionals.Force.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ValidateOnly.IsSet() {
		localVarQueryParams.Add("validate_only", parameterToString(localVarOptionals.ValidateOnly.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
 * ClustersClusterIdLinksLinkNameGet Describe the cluster link
 *
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param clusterId The Kafka cluster ID.
 * @param linkName The link name
 * @return ListLinksResponseData
 */
func (a *ClusterLinkingApiService) ClustersClusterIdLinksLinkNameGet(ctx _context.Context, clusterId string, linkName string) (ListLinksResponseData, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ListLinksResponseData
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/clusters/{cluster_id}/links/{link_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(clusterId, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"link_name"+"}", _neturl.PathEscape(parameterToString(linkName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ClustersClusterIdLinksLinkNameMirrorsGetOpts Optional parameters for the method 'ClustersClusterIdLinksLinkNameMirrorsGet'
type ClustersClusterIdLinksLinkNameMirrorsGetOpts struct {
	MirrorStatus optional.Interface
}

/*
 * ClustersClusterIdLinksLinkNameMirrorsGet List mirror topics
 *
 * List all mirror topics under the link
 *
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param clusterId The Kafka cluster ID.
 * @param linkName The link name
 * @param optional nil or *ClustersClusterIdLinksLinkNameMirrorsGetOpts - Optional Parameters:
 * @param "MirrorStatus" (optional.Interface of MirrorTopicStatus) -  The status of the mirror topic. If not specified, all mirror topics will be returned.
 * @return ListMirrorTopicsResponseDataList
 */
func (a *ClusterLinkingApiService) ClustersClusterIdLinksLinkNameMirrorsGet(ctx _context.Context, clusterId string, linkName string, localVarOptionals *ClustersClusterIdLinksLinkNameMirrorsGetOpts) (ListMirrorTopicsResponseDataList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ListMirrorTopicsResponseDataList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/clusters/{cluster_id}/links/{link_name}/mirrors"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(clusterId, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"link_name"+"}", _neturl.PathEscape(parameterToString(linkName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.MirrorStatus.IsSet() {
		localVarQueryParams.Add("mirror_status", parameterToString(localVarOptionals.MirrorStatus.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
 * ClustersClusterIdLinksLinkNameMirrorsMirrorTopicNameGet Describe the mirror topic
 *
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param clusterId The Kafka cluster ID.
 * @param linkName The link name
 * @param mirrorTopicName Cluster Linking mirror topic name
 * @return ListMirrorTopicsResponseData
 */
func (a *ClusterLinkingApiService) ClustersClusterIdLinksLinkNameMirrorsMirrorTopicNameGet(ctx _context.Context, clusterId string, linkName string, mirrorTopicName string) (ListMirrorTopicsResponseData, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ListMirrorTopicsResponseData
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/clusters/{cluster_id}/links/{link_name}/mirrors/{mirror_topic_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(clusterId, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"link_name"+"}", _neturl.PathEscape(parameterToString(linkName, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"mirror_topic_name"+"}", _neturl.PathEscape(parameterToString(mirrorTopicName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ClustersClusterIdLinksLinkNameMirrorsPostOpts Optional parameters for the method 'ClustersClusterIdLinksLinkNameMirrorsPost'
type ClustersClusterIdLinksLinkNameMirrorsPostOpts struct {
	CreateMirrorTopicRequestData optional.Interface
}

/*
 * ClustersClusterIdLinksLinkNameMirrorsPost Create a mirror topic
 *
 * Create a topic in the destination cluster mirroring a topic in the source cluster
 *
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param clusterId The Kafka cluster ID.
 * @param linkName The link name
 * @param optional nil or *ClustersClusterIdLinksLinkNameMirrorsPostOpts - Optional Parameters:
 * @param "CreateMirrorTopicRequestData" (optional.Interface of CreateMirrorTopicRequestData) -  Name and configs of the topics mirroring from and mirroring to
 */
func (a *ClusterLinkingApiService) ClustersClusterIdLinksLinkNameMirrorsPost(ctx _context.Context, clusterId string, linkName string, localVarOptionals *ClustersClusterIdLinksLinkNameMirrorsPostOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/clusters/{cluster_id}/links/{link_name}/mirrors"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(clusterId, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"link_name"+"}", _neturl.PathEscape(parameterToString(linkName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.CreateMirrorTopicRequestData.IsSet() {
		localVarOptionalCreateMirrorTopicRequestData, localVarOptionalCreateMirrorTopicRequestDataok := localVarOptionals.CreateMirrorTopicRequestData.Value().(CreateMirrorTopicRequestData)
		if !localVarOptionalCreateMirrorTopicRequestDataok {
			return nil, reportError("createMirrorTopicRequestData should be CreateMirrorTopicRequestData")
		}
		localVarPostBody = &localVarOptionalCreateMirrorTopicRequestData
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// ClustersClusterIdLinksLinkNameMirrorsfailoverPostOpts Optional parameters for the method 'ClustersClusterIdLinksLinkNameMirrorsfailoverPost'
type ClustersClusterIdLinksLinkNameMirrorsfailoverPostOpts struct {
	ValidateOnly            optional.Bool
	AlterMirrorsRequestData optional.Interface
}

/*
 * ClustersClusterIdLinksLinkNameMirrorsfailoverPost Failover the mirror topics
 *
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param clusterId The Kafka cluster ID.
 * @param linkName The link name
 * @param optional nil or *ClustersClusterIdLinksLinkNameMirrorsfailoverPostOpts - Optional Parameters:
 * @param "ValidateOnly" (optional.Bool) -  To validate the action can be performed successfully or not. Default: false
 * @param "AlterMirrorsRequestData" (optional.Interface of AlterMirrorsRequestData) -  Name of the topics to apply the changes
 * @return AlterMirrorStatusResponseDataList
 */
func (a *ClusterLinkingApiService) ClustersClusterIdLinksLinkNameMirrorsfailoverPost(ctx _context.Context, clusterId string, linkName string, localVarOptionals *ClustersClusterIdLinksLinkNameMirrorsfailoverPostOpts) (AlterMirrorStatusResponseDataList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AlterMirrorStatusResponseDataList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/clusters/{cluster_id}/links/{link_name}/mirrors:failover"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(clusterId, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"link_name"+"}", _neturl.PathEscape(parameterToString(linkName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.ValidateOnly.IsSet() {
		localVarQueryParams.Add("validate_only", parameterToString(localVarOptionals.ValidateOnly.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.AlterMirrorsRequestData.IsSet() {
		localVarOptionalAlterMirrorsRequestData, localVarOptionalAlterMirrorsRequestDataok := localVarOptionals.AlterMirrorsRequestData.Value().(AlterMirrorsRequestData)
		if !localVarOptionalAlterMirrorsRequestDataok {
			return localVarReturnValue, nil, reportError("alterMirrorsRequestData should be AlterMirrorsRequestData")
		}
		localVarPostBody = &localVarOptionalAlterMirrorsRequestData
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ClustersClusterIdLinksLinkNameMirrorspausePostOpts Optional parameters for the method 'ClustersClusterIdLinksLinkNameMirrorspausePost'
type ClustersClusterIdLinksLinkNameMirrorspausePostOpts struct {
	ValidateOnly            optional.Bool
	AlterMirrorsRequestData optional.Interface
}

/*
 * ClustersClusterIdLinksLinkNameMirrorspausePost Pause the mirror topics
 *
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param clusterId The Kafka cluster ID.
 * @param linkName The link name
 * @param optional nil or *ClustersClusterIdLinksLinkNameMirrorspausePostOpts - Optional Parameters:
 * @param "ValidateOnly" (optional.Bool) -  To validate the action can be performed successfully or not. Default: false
 * @param "AlterMirrorsRequestData" (optional.Interface of AlterMirrorsRequestData) -  Name of the topics to apply the changes
 * @return AlterMirrorStatusResponseDataList
 */
func (a *ClusterLinkingApiService) ClustersClusterIdLinksLinkNameMirrorspausePost(ctx _context.Context, clusterId string, linkName string, localVarOptionals *ClustersClusterIdLinksLinkNameMirrorspausePostOpts) (AlterMirrorStatusResponseDataList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AlterMirrorStatusResponseDataList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/clusters/{cluster_id}/links/{link_name}/mirrors:pause"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(clusterId, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"link_name"+"}", _neturl.PathEscape(parameterToString(linkName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.ValidateOnly.IsSet() {
		localVarQueryParams.Add("validate_only", parameterToString(localVarOptionals.ValidateOnly.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.AlterMirrorsRequestData.IsSet() {
		localVarOptionalAlterMirrorsRequestData, localVarOptionalAlterMirrorsRequestDataok := localVarOptionals.AlterMirrorsRequestData.Value().(AlterMirrorsRequestData)
		if !localVarOptionalAlterMirrorsRequestDataok {
			return localVarReturnValue, nil, reportError("alterMirrorsRequestData should be AlterMirrorsRequestData")
		}
		localVarPostBody = &localVarOptionalAlterMirrorsRequestData
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ClustersClusterIdLinksLinkNameMirrorspromotePostOpts Optional parameters for the method 'ClustersClusterIdLinksLinkNameMirrorspromotePost'
type ClustersClusterIdLinksLinkNameMirrorspromotePostOpts struct {
	ValidateOnly            optional.Bool
	AlterMirrorsRequestData optional.Interface
}

/*
 * ClustersClusterIdLinksLinkNameMirrorspromotePost Promote the mirror topics
 *
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param clusterId The Kafka cluster ID.
 * @param linkName The link name
 * @param optional nil or *ClustersClusterIdLinksLinkNameMirrorspromotePostOpts - Optional Parameters:
 * @param "ValidateOnly" (optional.Bool) -  To validate the action can be performed successfully or not. Default: false
 * @param "AlterMirrorsRequestData" (optional.Interface of AlterMirrorsRequestData) -  Name of the topics to apply the changes
 * @return AlterMirrorStatusResponseDataList
 */
func (a *ClusterLinkingApiService) ClustersClusterIdLinksLinkNameMirrorspromotePost(ctx _context.Context, clusterId string, linkName string, localVarOptionals *ClustersClusterIdLinksLinkNameMirrorspromotePostOpts) (AlterMirrorStatusResponseDataList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AlterMirrorStatusResponseDataList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/clusters/{cluster_id}/links/{link_name}/mirrors:promote"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(clusterId, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"link_name"+"}", _neturl.PathEscape(parameterToString(linkName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.ValidateOnly.IsSet() {
		localVarQueryParams.Add("validate_only", parameterToString(localVarOptionals.ValidateOnly.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.AlterMirrorsRequestData.IsSet() {
		localVarOptionalAlterMirrorsRequestData, localVarOptionalAlterMirrorsRequestDataok := localVarOptionals.AlterMirrorsRequestData.Value().(AlterMirrorsRequestData)
		if !localVarOptionalAlterMirrorsRequestDataok {
			return localVarReturnValue, nil, reportError("alterMirrorsRequestData should be AlterMirrorsRequestData")
		}
		localVarPostBody = &localVarOptionalAlterMirrorsRequestData
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ClustersClusterIdLinksLinkNameMirrorsresumePostOpts Optional parameters for the method 'ClustersClusterIdLinksLinkNameMirrorsresumePost'
type ClustersClusterIdLinksLinkNameMirrorsresumePostOpts struct {
	ValidateOnly            optional.Bool
	AlterMirrorsRequestData optional.Interface
}

/*
 * ClustersClusterIdLinksLinkNameMirrorsresumePost Resume the mirror topics
 *
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param clusterId The Kafka cluster ID.
 * @param linkName The link name
 * @param optional nil or *ClustersClusterIdLinksLinkNameMirrorsresumePostOpts - Optional Parameters:
 * @param "ValidateOnly" (optional.Bool) -  To validate the action can be performed successfully or not. Default: false
 * @param "AlterMirrorsRequestData" (optional.Interface of AlterMirrorsRequestData) -  Name of the topics to apply the changes
 * @return AlterMirrorStatusResponseDataList
 */
func (a *ClusterLinkingApiService) ClustersClusterIdLinksLinkNameMirrorsresumePost(ctx _context.Context, clusterId string, linkName string, localVarOptionals *ClustersClusterIdLinksLinkNameMirrorsresumePostOpts) (AlterMirrorStatusResponseDataList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AlterMirrorStatusResponseDataList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/clusters/{cluster_id}/links/{link_name}/mirrors:resume"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(clusterId, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"link_name"+"}", _neturl.PathEscape(parameterToString(linkName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.ValidateOnly.IsSet() {
		localVarQueryParams.Add("validate_only", parameterToString(localVarOptionals.ValidateOnly.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.AlterMirrorsRequestData.IsSet() {
		localVarOptionalAlterMirrorsRequestData, localVarOptionalAlterMirrorsRequestDataok := localVarOptionals.AlterMirrorsRequestData.Value().(AlterMirrorsRequestData)
		if !localVarOptionalAlterMirrorsRequestDataok {
			return localVarReturnValue, nil, reportError("alterMirrorsRequestData should be AlterMirrorsRequestData")
		}
		localVarPostBody = &localVarOptionalAlterMirrorsRequestData
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ClustersClusterIdLinksMirrorsGetOpts Optional parameters for the method 'ClustersClusterIdLinksMirrorsGet'
type ClustersClusterIdLinksMirrorsGetOpts struct {
	MirrorStatus optional.Interface
}

/*
 * ClustersClusterIdLinksMirrorsGet List mirror topics
 *
 * List all mirror topics in the cluster
 *
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param clusterId The Kafka cluster ID.
 * @param optional nil or *ClustersClusterIdLinksMirrorsGetOpts - Optional Parameters:
 * @param "MirrorStatus" (optional.Interface of MirrorTopicStatus) -  The status of the mirror topic. If not specified, all mirror topics will be returned.
 * @return ListMirrorTopicsResponseDataList
 */
func (a *ClusterLinkingApiService) ClustersClusterIdLinksMirrorsGet(ctx _context.Context, clusterId string, localVarOptionals *ClustersClusterIdLinksMirrorsGetOpts) (ListMirrorTopicsResponseDataList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ListMirrorTopicsResponseDataList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/clusters/{cluster_id}/links/-/mirrors"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(clusterId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.MirrorStatus.IsSet() {
		localVarQueryParams.Add("mirror_status", parameterToString(localVarOptionals.MirrorStatus.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ClustersClusterIdLinksPostOpts Optional parameters for the method 'ClustersClusterIdLinksPost'
type ClustersClusterIdLinksPostOpts struct {
	ValidateOnly          optional.Bool
	ValidateLink          optional.Bool
	CreateLinkRequestData optional.Interface
}

/*
 * ClustersClusterIdLinksPost Create a cluster link
 *
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param clusterId The Kafka cluster ID.
 * @param linkName The link name
 * @param optional nil or *ClustersClusterIdLinksPostOpts - Optional Parameters:
 * @param "ValidateOnly" (optional.Bool) -  To validate the action can be performed successfully or not. Default: false
 * @param "ValidateLink" (optional.Bool) -  To synchronously validate that the source cluster ID is expected and the dest cluster has the permission to read topics in the source cluster. Default: true
 * @param "CreateLinkRequestData" (optional.Interface of CreateLinkRequestData) -  Create a cluster link
 */
func (a *ClusterLinkingApiService) ClustersClusterIdLinksPost(ctx _context.Context, clusterId string, linkName string, localVarOptionals *ClustersClusterIdLinksPostOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/clusters/{cluster_id}/links"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(clusterId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("link_name", parameterToString(linkName, ""))
	if localVarOptionals != nil && localVarOptionals.ValidateOnly.IsSet() {
		localVarQueryParams.Add("validate_only", parameterToString(localVarOptionals.ValidateOnly.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ValidateLink.IsSet() {
		localVarQueryParams.Add("validate_link", parameterToString(localVarOptionals.ValidateLink.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.CreateLinkRequestData.IsSet() {
		localVarOptionalCreateLinkRequestData, localVarOptionalCreateLinkRequestDataok := localVarOptionals.CreateLinkRequestData.Value().(CreateLinkRequestData)
		if !localVarOptionalCreateLinkRequestDataok {
			return nil, reportError("createLinkRequestData should be CreateLinkRequestData")
		}
		localVarPostBody = &localVarOptionalCreateLinkRequestData
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
